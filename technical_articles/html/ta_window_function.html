<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostgreSQLで学ぶ「ウィンドウ関数とGROUPING」の実践：高度な集計・分析クエリを極める</title>
    <style>
        :root {
            --primary-color: #3182ce;
            --bg-color: #f7fafc;
            --text-color: #2d3748;
            --code-bg: #edf2f7;
            --border-color: #e2e8f0;
            --alert-bg: #fffaf0;
            --alert-border: #ed8936;
            --scenario-bg: #f0fff4;
            --scenario-border: #38a169;
            --column-bg: #e6fffa;
            --column-border: #319795;
            --table-header-bg: #edf2f7;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: 850px;
            margin: 0 auto;
            background: #ffffff;
            padding: 3rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        h1 {
            font-size: 2rem;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
            line-height: 1.3;
        }
        h2 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3rem;
        }
        h3 {
            font-size: 1.25rem;
            margin-top: 2rem;
            color: #4a5568;
            border-left: 5px solid var(--primary-color);
            padding-left: 0.8rem;
        }
        p {
            margin-bottom: 1.5rem;
        }
        ul, ol {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            border: 1px solid var(--border-color);
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .terminal-output {
            background-color: #2d3748;
            color: #e2e8f0;
            border: none;
        }
        .comment {
            color: #718096;
            font-style: italic;
        }
        code {
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            color: #d53f8c;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: bold;
            color: #4a5568;
        }
        .data-table th {
            text-align: center;
        }
        .data-table td {
            text-align: center;
        }
        .note {
            background-color: #ebf8ff;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        .alert {
            background-color: var(--alert-bg);
            border: 1px solid var(--alert-border);
            border-left: 6px solid var(--alert-border);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .alert strong {
            color: #c05621;
            display: block;
            margin-bottom: 0.5rem;
        }
        .scenario {
            background-color: var(--scenario-bg);
            border: 1px solid var(--scenario-border);
            border-radius: 6px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
        }
        .scenario-title {
            font-weight: bold;
            color: var(--scenario-border);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }
        .column {
            background-color: var(--column-bg);
            border: 1px solid var(--column-border);
            border-radius: 6px;
            padding: 1rem 1.5rem;
            margin: 2rem 0;
        }
        .column-title {
            font-weight: bold;
            color: var(--column-border);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        .step-box {
            background-color: #fcfcfc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .step-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        .toc {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 0;
        }
        .toc li {
            margin-bottom: 0.5rem;
        }
        .toc a {
            text-decoration: none;
            color: var(--primary-color);
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .visual-compare {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .visual-box {
            flex: 1;
            background: #fff;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            padding: 1rem;
            text-align: center;
        }
        .visual-box h4 {
            margin-top: 0;
            color: #2d3748;
            font-size: 1rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }
        .visual-data {
            font-family: monospace;
            background: #edf2f7;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        .arrow {
            color: #a0aec0;
            font-size: 1.5rem;
            margin: 0.5rem 0;
        }
        .highlight-data {
            background: #feebc8;
            border: 1px solid #d69e2e;
        }
        .terminal-img {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 1rem 0;
            display: block;
        }
        .footer {
            margin-top: 4rem;
            padding-top: 1rem;
            border-top: 1px dashed var(--border-color);
            text-align: right;
            color: #718096;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PostgreSQLで学ぶ「ウィンドウ関数とGROUPING」の実践：高度な集計・分析クエリを極める</h1>

        <div class="toc">
            <strong>目次</strong>
            <ul>
                <li><a href="#ch0">0. はじめに（この記事のゴール）</a></li>
                <li><a href="#ch1">1. 実行環境とテーブル定義</a></li>
                <li><a href="#ch2">2. ウィンドウ関数とは何か？（GROUP BYとの決定的な違い）</a></li>
                <li><a href="#ch3">3. 高度な集約：GROUPING機能とは？</a></li>
                <li><a href="#ch4">4. 実験: 挙動と効果を検証する（ハンズオン）</a></li>
                <li><a href="#ch5">5. 演習課題（全5問）</a></li>
                <li><a href="#ch6">6. まとめ</a></li>
            </ul>
        </div>

        <h2 id="ch0">0. はじめに（この記事のゴール）</h2>
        <p>
            データベースで「各部門の平均売上」や「合計点」を出す際、私たちは当然のように <code>GROUP BY</code> を使ってきました。しかし、実務の現場では要件がより複雑になります。「個人の売上データ（明細）はそのまま表示しつつ、その横に部門の平均売上も並べて比較したい」や、「売上の高い順にランキング（順位）をつけたい」、さらには「部門ごとの小計と全社の総合計を一度のクエリで出力した美しいレポートを作りたい」といった要望です。
        </p>
        <p>
            これらを通常の <code>GROUP BY</code> やサブクエリ（副問合せ）、自己結合（SELF JOIN）だけで解決しようとすると、SQLが非常に長く難解になり、データベースのパフォーマンスも著しく低下してしまいます。
        </p>
        <p>
            このような複雑な分析要件を美しく、かつ高速に解決するものが<strong>「ウィンドウ関数（Window Functions）」</strong>と高度な<strong>「GROUPING機能」</strong>です。本記事では、講義の演習環境（PostgreSQL 17 コンテナ）を用いて以下のゴールを目指します。
        </p>
        <ul>
            <li><code>GROUP BY</code> とウィンドウ関数の決定的な違いを視覚的に理解し、用途を明確に分ける。</li>
            <li><code>RANK</code>, <code>ROW_NUMBER</code> を用いたランキング処理の微妙な挙動の違いを実装レベルで把握する。</li>
            <li><code>LAG / LEAD</code> を用いた「前月比」などの高度な時系列分析クエリを自力で書けるようになる。</li>
            <li><code>ROLLUP</code> と <code>GROUPING()</code> 関数を使いこなし、小計・総合計を一発で出力する技術を習得する。</li>
        </ul>

        <h2 id="ch1">1. 実行環境とテーブル定義</h2>
        <p>本記事の SQL は、以下の環境で動作確認を行っています。読者の皆さんも、ご自身の演習環境で実際に手を動かしながら読み進めてください。自分でクエリを叩き、結果のテーブルを見比べることが最大の学習になります。</p>

        <h3>実行環境</h3>
        <ul>
            <li><strong>ホスト OS:</strong> Windows 11 (WSL2) または macOS</li>
            <li><strong>DBMS:</strong> PostgreSQL 17</li>
            <li><strong>Docker イメージ:</strong> postgres:17.6</li>
            <li><strong>ポート:</strong> 5432</li>
        </ul>

        <div class="alert">
            <strong>⚠️ 環境構築に関する確認事項</strong>
            <ul>
                <li>Docker Desktop等のデーモンが起動していることを確認してください。</li>
                <li>ターミナルから <code>psql -U postgres -d postgres -h localhost</code> 等のコマンドを実行し、確実にデータベースに接続できていることを確認してから実験に進んでください。</li>
            </ul>
        </div>

        <h3>テーブル定義（検証用データ）</h3>
        <p>ウィンドウ関数とGROUPINGの挙動を確認するため、営業担当者の月ごとの売上データを管理する <code>sales_records</code> テーブルを作成します。</p>
<pre><code><span class="comment">-- 売上管理テーブルの作成</span>
DROP TABLE IF EXISTS sales_records;
CREATE TABLE sales_records (
    id serial PRIMARY KEY,          <span class="comment">-- serial: 自動採番</span>
    sales_month text NOT NULL,      <span class="comment">-- 売上月 (例: '2024-04')</span>
    department text NOT NULL,       <span class="comment">-- 部署 (例: '第1営業部')</span>
    employee_name text NOT NULL,    <span class="comment">-- 社員名</span>
    amount int NOT NULL             <span class="comment">-- 売上金額（万円）</span>
);</code></pre>

        <h2 id="ch2">2. ウィンドウ関数とは何か？（GROUP BYとの決定的な違い）</h2>
        <p>
            ウィンドウ関数を理解する上で最も重要なのは、<strong>通常の「GROUP BY（集約処理）」とのアプローチの違い</strong>を明確にすることです。
        </p>
        
        <div class="visual-compare">
            <div class="visual-box">
                <h4>GROUP BY のイメージ</h4>
                <div class="visual-data">[第1営業部, 佐藤, 500]</div>
                <div class="visual-data">[第1営業部, 鈴木, 800]</div>
                <div class="arrow">↓ 複数行を圧縮（集約）</div>
                <div class="visual-data highlight-data">[第1営業部, 1300]</div>
                <p style="font-size: 0.85rem; text-align: left; margin-top: 1rem;">部署ごとの「合計」や「平均」は出せますが、<strong>行が圧縮されるため、佐藤さん・鈴木さんといった個別の明細データは完全に失われます。</strong></p>
            </div>
            <div class="visual-box">
                <h4>ウィンドウ関数のイメージ</h4>
                <div class="visual-data">[第1営業部, 佐藤, 500]</div>
                <div class="visual-data">[第1営業部, 鈴木, 800]</div>
                <div class="arrow">↓ 行を残したまま横に付与</div>
                <div class="visual-data highlight-data">[第1営業部, 佐藤, 500, <b>1300</b>]</div>
                <div class="visual-data highlight-data">[第1営業部, 鈴木, 800, <b>1300</b>]</div>
                <p style="font-size: 0.85rem; text-align: left; margin-top: 1rem;">行を圧縮しません。<strong>元の行（明細）を残したまま、その横に集計結果や順位を新たな列としてくっつける</strong>ことができます。</p>
            </div>
        </div>

        <p>
            この「計算の対象となる行のまとまり（上の例では『第1営業部』というくくり）」のことを、切り取られた窓枠に例えて<strong>ウィンドウ（窓）</strong>と呼びます。
        </p>

        <h3>2.1 基本構文</h3>
        <p>ウィンドウ関数は、通常の関数の後ろに <code>OVER()</code> 句を続ける特殊な構文を持ちます。</p>
<pre><code>SELECT 
    列名,
    ウィンドウ関数() OVER (
        [PARTITION BY グループ化する列] 
        [ORDER BY 並べ替える列]
        [フレーム指定 (ROWS / RANGE BETWEEN ...)]
    )
FROM テーブル名;</code></pre>

        <p><strong>▼具体例：部署ごとに売上の高い順に順位をつける</strong></p>
<pre><code>SELECT 
    employee_name,
    department,
    amount,
    RANK() OVER (
        PARTITION BY department  <span class="comment">-- 部署ごとにウィンドウ（計算の枠）を分割する</span>
        ORDER BY amount DESC     <span class="comment">-- その枠の中で、売上金額（amount）が高い順に並べ替える</span>
    ) AS dept_rank               <span class="comment">-- 計算結果の列に「dept_rank」と名前をつける</span>
FROM sales_records;</code></pre>
        <p>このように、<code>OVER()</code> 句の中に「どのようにグループを区切るか」「どのような順序で計算するか」という条件を記述していくのが、ウィンドウ関数の基本的な書き方です。</p>

        <h3>2.2 代表的なウィンドウ関数の種類</h3>
        <p>ウィンドウ関数として使える関数は、用途によって大きく3つのグループに分類されます。実務で求められる分析要件に応じて適切に使い分ける必要があります。</p>
        <table>
            <thead>
                <tr>
                    <th>種類</th>
                    <th>代表的な関数</th>
                    <th>用途・特徴と具体的な利用シーン</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>順序付け関数</strong><br>(ランキング)</td>
                    <td><code>RANK()</code>, <code>DENSE_RANK()</code>, <code>ROW_NUMBER()</code></td>
                    <td>売上ランキングの作成や、「各ユーザーの最新のログイン履歴を1件だけ取得する」といった用途で多用されます。同率順位が出た際の「順位の飛び方」に明確な違いがあります。</td>
                </tr>
                <tr>
                    <td><strong>ナビゲーション関数</strong><br>(オフセット)</td>
                    <td><code>LAG()</code>, <code>LEAD()</code>, <code>FIRST_VALUE()</code>, <code>LAST_VALUE()</code></td>
                    <td>行と行をまたいだ値の参照を可能にします。<code>LAG()</code> は「前の行」、<code>LEAD()</code> は「次の行」の値を取得します。売上の前月比計算、アクセスログの滞在時間（次のページへの遷移時間）の計算などに劇的な威力を発揮します。</td>
                </tr>
                <tr>
                    <td><strong>集約関数</strong></td>
                    <td><code>SUM()</code>, <code>AVG()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>COUNT()</code></td>
                    <td><code>GROUP BY</code> で使う通常の集約関数も、<code>OVER()</code> をつけることでウィンドウ関数に変身します。全体合計に対する個人の「売上構成比」や、日々の「累計売上」を計算する際に重宝します。</td>
                </tr>
            </tbody>
        </table>

        <h3>2.3 OVER() 句の中身（ウィンドウの定義）</h3>
        <p>ウィンドウ関数を使いこなすために重要なのは、<code>OVER()</code> の中で<strong>「どの範囲の行を、どういう順番で計算対象にするか」</strong>を正確に定義することです。主に以下の3要素で構成されます。</p>
        <ol>
            <li><strong>PARTITION BY（グループ化による窓枠の分割）：</strong> データを指定した列で分割（パーティショニング）します。<code>GROUP BY</code> に似ていますが、前述の通り行は圧縮されません。「部署ごとに順位をつけたい（部署が変わったら1位からやり直す）」場合は <code>PARTITION BY department</code> と指定します。省略した場合は「テーブル全体の行」が1つの巨大なウィンドウとして扱われます。</li>
            <li><strong>ORDER BY（窓枠内での並べ替え）：</strong> ウィンドウ内での行の計算順序を決定します。ランキングを出すための基準になったり、<code>LAG</code>（前の行を取得）を正しく機能させるための前提条件となります。</li>
            <li><strong>フレーム指定（ROWS BETWEEN）：</strong> <code>ORDER BY</code> で並べた行の中で、「ここからここまで」というさらに細かな計算範囲（サブウィンドウ：フレーム）を指定します。たとえば「直近の過去1ヶ月と現在の月（2ヶ月の移動平均）」といった、株価チャートのような高度な集計が可能になります。</li>
        </ol>

        <div class="column">
            <div class="column-title">💡 コラム：ORDER BY を書くと「累計」になる暗黙のルール</div>
            <p>
                集約関数（<code>SUM</code>など）をウィンドウ関数として使う際、<code>OVER()</code> の中に <code>ORDER BY</code> を記述すると、PostgreSQLは自動的に<strong>「最初の行から現在の行まで（ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW）」</strong>という計算範囲（フレーム）を暗黙的に設定します。<br>
                これにより、結果が「全体の合計」ではなく「（現在の行の）そこまでの累計」に変化するという非常に重要な性質があります。この法則を知らないと、「合計を出したいのに、なぜか行ごとに増えていく累計になってしまう…」と沼にハマることになります。
            </p>
        </div>

        <h2 id="ch3">3. 高度な集約：GROUPING機能とは？</h2>
        <p>
            ウィンドウ関数は「明細行を残す」機能でしたが、実務のレポート作成などでは全く逆の要望が出ます。それが、「部門ごとの小計行」や「全社の総合計行」といった<strong>高度に集約されたサマリー行</strong>を、通常の明細（または細かい粒度の集計）の間に差し込みたい、というケースです。<br>
            これをサブクエリや <code>UNION ALL</code>（別々のクエリ結果を縦に繋ぐ処理）を使って力技で実現しようとすると、同じテーブルを何度も読み込むことになり、クエリの実行速度が絶望的に遅くなります。<br>
            これを解決するのが、1回の読み込みで小計・総合計を一発で生成してくれる高度な <code>GROUP BY</code> 拡張機能です。
        </p>

        <ul>
            <li><strong>ROLLUP (A, B):</strong> 階層的な集計を行います。「AとBの組み合わせの集計」「Aごとの小計」「全体の総合計」を生成します。（「年 > 月」や「都道府県 > 市区町村」のような、明確な階層構造を持つデータに最適です）。</li>
            <li><strong>CUBE (A, B):</strong> 指定した列の「すべての組み合わせ」のクロス集計を行います。（Aのみ、Bのみ、AとB、全体の合計）。分析ダッシュボードなど多角的な視点が必要な場面で使われます。</li>
            <li><strong>GROUPING SETS:</strong> 不要な組み合わせを省き、必要な集計の組み合わせだけをピンポイントで指定する、最も柔軟な記法です。</li>
        </ul>

        <h3>GROUPING() 関数の役割（NULLの正体を見破る）</h3>
        <p>
            <code>ROLLUP</code> 等を使って小計行を生成すると、その行の集約の基準とならなかった列（例えば部門ごとの小計行における、担当者名の列など）には <strong><code>NULL</code></strong> が入ります。<br>
            しかし、実データに元々NULLが含まれていた場合、「データとしての本物のNULLなのか」、それとも「ROLLUPが生成した集計行の証拠としてのNULLなのか」が見分けられなくなります。そこで <strong><code>GROUPING(列名)</code></strong> 関数を使います。<br>
            この関数は、<strong>集約によって生成されたNULLであれば <code>1</code> を、それ以外の通常のデータ（本物のNULL含む）なら <code>0</code> を返します。</strong>この性質を利用し、レポートのラベルを「NULL」から「総合計」といった人間に読みやすい文字へ置換する際になくてはならない関数です。
        </p>

        <h2 id="ch4">4. 実験: 挙動と効果を検証する（ハンズオン）</h2>
        <p>理論を押さえたところで、実際にコンテナ環境を用いて検証を進めます。ご自身のターミナルで結果を確かめながら進めてください。</p>

        <h3>4.1 検証用データセットの投入（準備）</h3>
        <div class="alert">
            <strong>⚠️ テーブル作成の確認</strong>
            <p>本実験を進める前に、第1章で紹介した <code>sales_records</code> テーブルの作成（<code>CREATE TABLE</code>）が完了していることを確認してください。</p>
        </div>
        
        <p>テーブルの準備ができたら、以下のSQLを実行してダミーデータを挿入します。今回はウィンドウ関数の複雑な挙動を目で見て確認しやすくするため、あえて少量のデータ（全15件）を手動で投入します。</p>

        <div class="step-box">
<pre><code><span class="comment">-- 15件のテストデータを挿入</span>
INSERT INTO sales_records (sales_month, department, employee_name, amount) VALUES
('2024-04', '第1営業部', '佐藤', 500),
('2024-04', '第1営業部', '鈴木', 800),
('2024-04', '第1営業部', '高橋', 800),
('2024-04', '第2営業部', '田中', 450),
('2024-04', '第2営業部', '伊藤', 700),
('2024-05', '第1営業部', '佐藤', 600),
('2024-05', '第1営業部', '鈴木', 900),
('2024-05', '第1営業部', '高橋', 850),
('2024-05', '第2営業部', '田中', 500),
('2024-05', '第2営業部', '伊藤', 750),
('2024-06', '第1営業部', '佐藤', 550),
('2024-06', '第1営業部', '鈴木', 850),
('2024-06', '第1営業部', '高橋', 900),
('2024-06', '第2営業部', '田中', 600),
('2024-06', '第2営業部', '伊藤', 800);</code></pre>
        </div>

        <p><strong>▼初期状態の <code>sales_records</code> テーブル（全15件）</strong></p>
        <p>これから行う実験は、すべてこのデータセットに対して実行されます。誰がどの月にいくら売り上げたか、イメージをつかんでおきましょう。</p>
        <table class="data-table">
            <thead>
                <tr>
                    <th>id</th>
                    <th>sales_month</th>
                    <th>department</th>
                    <th>employee_name</th>
                    <th>amount</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>2024-04</td><td>第1営業部</td><td>佐藤</td><td>500</td></tr>
                <tr><td>2</td><td>2024-04</td><td>第1営業部</td><td>鈴木</td><td>800</td></tr>
                <tr><td>3</td><td>2024-04</td><td>第1営業部</td><td>高橋</td><td>800</td></tr>
                <tr><td>4</td><td>2024-04</td><td>第2営業部</td><td>田中</td><td>450</td></tr>
                <tr><td>5</td><td>2024-04</td><td>第2営業部</td><td>伊藤</td><td>700</td></tr>
                <tr><td>6</td><td>2024-05</td><td>第1営業部</td><td>佐藤</td><td>600</td></tr>
                <tr><td>7</td><td>2024-05</td><td>第1営業部</td><td>鈴木</td><td>900</td></tr>
                <tr><td>8</td><td>2024-05</td><td>第1営業部</td><td>高橋</td><td>850</td></tr>
                <tr><td>9</td><td>2024-05</td><td>第2営業部</td><td>田中</td><td>500</td></tr>
                <tr><td>10</td><td>2024-05</td><td>第2営業部</td><td>伊藤</td><td>750</td></tr>
                <tr><td>11</td><td>2024-06</td><td>第1営業部</td><td>佐藤</td><td>550</td></tr>
                <tr><td>12</td><td>2024-06</td><td>第1営業部</td><td>鈴木</td><td>850</td></tr>
                <tr><td>13</td><td>2024-06</td><td>第1営業部</td><td>高橋</td><td>900</td></tr>
                <tr><td>14</td><td>2024-06</td><td>第2営業部</td><td>田中</td><td>600</td></tr>
                <tr><td>15</td><td>2024-06</td><td>第2営業部</td><td>伊藤</td><td>800</td></tr>
            </tbody>
        </table>

        <h3>4.2 実験A: 基本のランキング関数（RANK / DENSE_RANK / ROW_NUMBER）</h3>
        
        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 2024年4月の売上データにおいて、売上が高い順に社員のランキング表を作成したい。<br>
                <strong>検証の狙い：</strong> 順位をつける代表的な3つのウィンドウ関数の挙動の違いを比較します。特に「鈴木さんと高橋さんが800万円で同率」というケースにおいて、順位がどのように採番されるかに注目します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>3つの関数を同時に実行して比較する</strong>
                    <pre><code>SELECT 
    employee_name, 
    amount,
    RANK() OVER (ORDER BY amount DESC) AS "rank",
    DENSE_RANK() OVER (ORDER BY amount DESC) AS "dense_rank",
    ROW_NUMBER() OVER (ORDER BY amount DESC) AS "row_number"
FROM sales_records
WHERE sales_month = '2024-04';</code></pre>
                </li>
            </ol>
            <p><strong>▼ターミナル出力結果</strong></p>
            <img src="../png/window_a.png" alt="実験Aのターミナル出力" class="terminal-img">

            <div class="note">
                <strong>【結果の考察】</strong><br>
                鈴木さんと高橋さんが同額（800）である点に着目してください。<br>
                ・<strong>RANK()：</strong> 1位が2人いるため、次の伊藤さんの順位は「3位」にスキップしています。一般的なスポーツの順位などと同じ挙動です。<br>
                ・<strong>DENSE_RANK()：</strong> 1位が2人いても、次の伊藤さんは「2位」になります。順位のギャップ（隙間）を作らないという特性があります。<br>
                ・<strong>ROW_NUMBER()：</strong> 同額であっても無理やり一意の連番（1, 2, 3...）を振ります。「トップ10件だけを必ず取得したい（同率が何人いようが10件で切る）」といった要件で重宝します。
            </div>
        </div>

        <h3>4.3 実験B: グループごとの処理（PARTITION BY）</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 会社全体の売上ランキングではなく、「部署ごとの」売上トップは誰か？を一覧で取得したい。<br>
                <strong>検証の狙い：</strong> <code>OVER()</code> 句の中に <code>PARTITION BY</code> を追加することで、ウィンドウ（計算対象の枠）がグループごとに分割され、部署が変わるたびに順位がリセットされることを確認します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>部署ごとに順位をリセットして計算する</strong>
                    <pre><code>SELECT 
    department,
    employee_name, 
    amount,
    RANK() OVER (PARTITION BY department ORDER BY amount DESC) AS dept_rank
FROM sales_records
WHERE sales_month = '2024-05';</code></pre>
                </li>
            </ol>
            <p><strong>▼ターミナル出力結果</strong></p>
            <img src="../png/window_b.png" alt="実験Bのターミナル出力" class="terminal-img">

            <div class="note">
                <strong>【結果の考察】</strong><br>
                結果を見ると、<code>department</code>（部署）が「第1営業部」から「第2営業部」に切り替わったタイミング（伊藤さんの行）で、<code>dept_rank</code> が再び「1」から再スタートしていることが明確にわかります。<code>PARTITION BY</code> が「計算の窓枠を部署ごとに区切っている」という何よりの証拠です。
            </div>
        </div>

        <h3>4.4 実験C: 集約関数をウィンドウ関数として使う（売上構成比の計算）</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 各社員の売上が、所属する部署全体の売上の「何パーセント（構成比）」を占めているかを計算して出力したい。<br>
                <strong>検証の狙い：</strong> <code>SUM()</code> などの通常の集約関数も、<code>OVER()</code> をつけることでウィンドウ関数として機能し、「個人の明細行を残したまま、部署の全体合計を取得できる」という強みを検証します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>個人の売上と、部署の合計売上を横に並べて割り算を行う</strong>
                    <pre><code>SELECT 
    department,
    employee_name, 
    amount AS personal_amount,
    -- 部署内の合計売上を計算（ORDER BYがない点に注意。累計ではなく純粋な合計になる）
    SUM(amount) OVER (PARTITION BY department) AS dept_total,
    -- 構成比の計算（個人売上 ÷ 部署合計 × 100）
    ROUND(amount * 100.0 / SUM(amount) OVER (PARTITION BY department), 1) AS ratio_pct
FROM sales_records
WHERE sales_month = '2024-06'
ORDER BY department, amount DESC;</code></pre>
                </li>
            </ol>
            <p><strong>▼ターミナル出力結果</strong></p>
            <img src="../png/window_c.png" alt="実験Cのターミナル出力" class="terminal-img">

            <div class="note">
                <strong>【結果の考察】</strong><br>
                通常の <code>GROUP BY</code> では社員名（明細）が消えてしまいますが、出力結果を見ると「高橋」といった個人名がしっかり残っています。それなのに、そのすぐ横の <code>dept_total</code> 列には「第1営業部の合計値（2300）」や「第2営業部の合計値（1400）」が正しく入っています。<br>
                この「明細」と「全体合計」が1つの行に同居できる特性のおかげで、<code>900 ÷ 2300</code> といった構成比の計算（<code>ratio_pct</code>）がシンプルなSQLで実現できました。
            </div>
        </div>

        <h3>4.5 実験D: LAG / LEAD関数による「前月比」の計算</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 各社員の月ごとの売上推移を追い、「先月の売上」と比較してどれくらい成長したか（前月差額）を出したい。<br>
                <strong>検証の狙い：</strong> 行と行をまたいだ比較が簡単にできる <code>LAG()</code>（前の行を取得）関数の威力を体感します。アプリケーション側でループ処理を書かなくても、SQLだけで時系列の比較計算が完結することを確認します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>社員ごとに時系列で並べ、1つ前の行の値を取得する</strong>
                    <pre><code>SELECT 
    employee_name,
    sales_month,
    amount AS current_amount,
    -- PARTITION BY で社員ごとに分割し、sales_month 順に並べた際の「1つ前の行」を取得
    LAG(amount) OVER (PARTITION BY employee_name ORDER BY sales_month) AS prev_amount,
    -- 前月との差額
    amount - LAG(amount) OVER (PARTITION BY employee_name ORDER BY sales_month) AS diff
FROM sales_records
WHERE employee_name = '佐藤' OR employee_name = '伊藤'
ORDER BY employee_name, sales_month;</code></pre>
                </li>
            </ol>
            <p><strong>▼ターミナル出力結果</strong></p>
            <img src="../png/window_d.png" alt="実験Dのターミナル出力" class="terminal-img">

            <div class="note">
                <strong>【結果の考察】</strong><br>
                4月の <code>prev_amount</code> は、比較対象となる「前の月」が存在しないため正しく <code>NULL</code> になっています。一方で5月、6月の行には、見事にその人の「1ヶ月前の売上」がズレて入り込んでおり、差額（<code>diff</code>）も 100 や -50 と正確に計算されています。<br>
                自己結合（SELF JOIN）などの複雑なSQLを書かなくても、前月比や前年同月比がこれほど簡単に取得できるのは、<code>LAG()</code> や <code>LEAD()</code> ならではの強力なメリットです。
            </div>
        </div>

        <h3>4.6 実験E: GROUPINGとROLLUPによる小計・総合計の算出</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 売上レポートを作成するために、「各部署ごとの売上合計（小計）」と、「全社の売上合計（総合計）」を1つのクエリで同時に出力したい。<br>
                <strong>検証の狙い：</strong> 単純な <code>GROUP BY</code> を拡張する <code>ROLLUP</code> 機能と、集計によって生成された行（NULL行）を正確に判別する <code>GROUPING()</code> 関数の使い方を学びます。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>ROLLUPを使って小計と総合計を出す</strong>
                    <pre><code>SELECT 
    sales_month,
    department,
    SUM(amount) AS total_amount,
    -- GROUPING関数は、その列が集約（ROLLUP等で計算）されてできたNULLなら「1」を返す
    GROUPING(sales_month) AS is_month_total,
    GROUPING(department) AS is_dept_total
FROM sales_records
GROUP BY ROLLUP(sales_month, department)
ORDER BY sales_month, department;</code></pre>
                </li>
            </ol>
            <p><strong>▼ターミナル出力結果</strong></p>
            <img src="../png/window_e.png" alt="実験Eのターミナル出力" class="terminal-img">

            <div class="note">
                <strong>【結果の考察】</strong><br>
                <code>GROUP BY ROLLUP(sales_month, department)</code> と指定したことで、出力結果の中に「月と部署の組み合わせ」「各月の小計（departmentが空白）」「全社の総合計（月も部署も空白）」の3パターンが一度のクエリで生成されています。<br>
                注目すべきは、小計や総合計の行における <code>is_month_total</code> と <code>is_dept_total</code> のフラグです。これらが「1」になっていることで、その空白（NULL）が「ROLLUPによって作られた集計用の枠である」と明確に判別できています。このフラグを後述の演習問題5で活用します。
            </div>
        </div>

        <h2 id="ch5">5. 演習課題（全5問）</h2>
        <p>ウィンドウ関数とGROUPINGの威力を理解したところで、以下の5つの実践問題に挑戦してみましょう。実務のデータ分析で必ず求められるレベルのクエリです。</p>

        <h3>問題1：シンプルな累計（Running Total）の計算（難易度：⭐⭐）</h3>
        <p>
            <strong>【問題】</strong><br>
            「田中」さんの月ごとの売上と、その月までの「累計売上（cumulative_sum）」を計算するクエリを書いてください。
        </p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答例：</strong>
            </p>
<pre><code>SELECT 
    sales_month,
    amount,
    SUM(amount) OVER (ORDER BY sales_month) AS cumulative_sum
FROM sales_records
WHERE employee_name = '田中'
ORDER BY sales_month;</code></pre>
            <p>
                <strong>解説：</strong> 集約関数の <code>SUM()</code> をウィンドウ関数として使いますが、実験Cのように <code>PARTITION BY</code> のみを使うと「全体の合計」になります。しかし、<code>OVER()</code> の中に <strong><code>ORDER BY</code> を指定すると、デフォルトで「最初の行から現在の行までの範囲」を集計する（＝累計になる）</strong>という非常に重要な特性（暗黙のフレーム指定ルール）を利用しています。
            </p>
        </details>

        <h3>問題2：上位N件の抽出（難易度：⭐⭐⭐）</h3>
        <p>
            <strong>【問題】</strong><br>
            2024年6月のデータで、「各部署」ごとに売上が上位1名の社員だけを抽出するクエリを記述してください。（同率1位はいないものとします）。<br>
            ヒント：ウィンドウ関数を含む列は、そのまま <code>WHERE</code> 句には書けないため、サブクエリ（またはCTE：WITH句）を使う必要があります。
        </p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答例：</strong>
            </p>
<pre><code>WITH RankedSales AS (
    SELECT 
        department,
        employee_name,
        amount,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY amount DESC) as rnk
    FROM sales_records
    WHERE sales_month = '2024-06'
)
SELECT department, employee_name, amount
FROM RankedSales
WHERE rnk = 1;</code></pre>
            <p>
                <strong>解説：</strong> SQLの実行順序（WHERE句はSELECT句より先に評価される）の制約上、<code>WHERE ROW_NUMBER() OVER(...) = 1</code> と直接書くことはできません。そのため、WITH句（CTE）を使って一度ランキング付きの仮想テーブルを作成し、メインクエリで <code>rnk = 1</code> を絞り込むのが、実務における王道パターンです。
            </p>
        </details>

        <h3>問題3：移動平均の計算（難易度：⭐⭐⭐⭐）</h3>
        <p>
            <strong>【問題】</strong><br>
            「佐藤」さんの売上について、当月と「直近の過去1ヶ月」を含めた「2ヶ月移動平均」を求めるクエリを記述してください。ウィンドウフレーム指定（<code>ROWS BETWEEN</code>）を利用します。
        </p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答例：</strong>
            </p>
<pre><code>SELECT 
    sales_month,
    amount,
    AVG(amount) OVER (
        ORDER BY sales_month 
        ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) AS moving_avg
FROM sales_records
WHERE employee_name = '佐藤'
ORDER BY sales_month;</code></pre>
            <p>
                <strong>解説：</strong> <code>ROWS BETWEEN X PRECEDING AND CURRENT ROW</code>（X行前から現在の行まで）というフレーム指定を行うことで、柔軟な移動平均や範囲集計が可能になります。株式チャートの「25日移動平均線」なども、この仕組みで非常にシンプルに計算できます。
            </p>
        </details>

        <h3>問題4：前月比（％）の算出（難易度：⭐⭐⭐⭐）</h3>
        <p>
            <strong>【問題】</strong><br>
            「第1営業部」の月ごとの合計売上を算出し、さらに「前月と比較して何パーセント成長したか（前月比）」を計算するクエリを記述してください。（例: 前月500、当月600なら120%）。
        </p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答例：</strong>
            </p>
<pre><code>WITH MonthlySales AS (
    SELECT 
        sales_month,
        SUM(amount) AS total_amount
    FROM sales_records
    WHERE department = '第1営業部'
    GROUP BY sales_month
)
SELECT 
    sales_month,
    total_amount,
    LAG(total_amount) OVER (ORDER BY sales_month) AS prev_amount,
    ROUND(total_amount * 100.0 / LAG(total_amount) OVER (ORDER BY sales_month), 1) AS growth_pct
FROM MonthlySales;</code></pre>
            <p>
                <strong>解説：</strong> まず通常の <code>GROUP BY</code> を使ったCTE（WITH句）で「月ごとの合計売上」を出します。次に、その集計結果に対して <code>LAG()</code> 関数を適用して前月データを持ってきて割り算します。「GROUP BYの集計結果に対して、さらにウィンドウ関数をかける」という実務で頻出するコンボ技です。
            </p>
        </details>

        <h3>問題5：GROUPING と COALESCE による美しい集計表（難易度：⭐⭐⭐⭐⭐）</h3>
        <p>
            <strong>【問題】</strong><br>
            実験Eで使用した <code>ROLLUP</code> のクエリを応用し、<code>GROUPING()</code> が「1」を返した場合（つまり小計や総合計の行の場合）は、<code>NULL</code> と表示するのではなく、文字列として「【総合計】」や「【小計】」という文字を出力するような、見やすい集計レポートを出力するクエリを記述してください。<br>
            ヒント：<code>CASE</code> 文を使います。
        </p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答例：</strong>
            </p>
<pre><code>SELECT 
    CASE 
        WHEN GROUPING(sales_month) = 1 THEN '【総合計】' 
        ELSE sales_month 
    END AS sales_month,
    CASE 
        WHEN GROUPING(department) = 1 AND GROUPING(sales_month) = 0 THEN '【小計】' 
        ELSE COALESCE(department, '') 
    END AS department,
    SUM(amount) AS total_amount
FROM sales_records
GROUP BY ROLLUP(sales_month, department)
ORDER BY sales_month, department;</code></pre>
            <p>
                <strong>解説：</strong> <code>GROUPING()</code> 関数は、まさにこのように「レポートの見た目を整える」ために存在しています。<code>CASE</code> 文と組み合わせることで、「月も部署もNULL（＝全体集計）なら総合計」「部署だけがNULL（＝月次集計）なら小計」といった柔軟なラベル付けが可能になり、アプリケーション側（フロントエンド）で加工する手間が省けます。
            </p>
        </details>


        <h2 id="ch6">6. まとめ</h2>
        <p>
            本記事では、SQLの表現力を飛躍的に高める「ウィンドウ関数」と「GROUPING機能」について学習しました。
        </p>
        <ul>
            <li><code>GROUP BY</code> と違い、明細行を保持したまま集計や順位付けができる。</li>
            <li><code>RANK</code> や <code>ROW_NUMBER</code> で柔軟なランキングが作れる。</li>
            <li><code>LAG</code> や累計計算により、複雑なプログラムを書かずともSQLだけで高度な時系列分析が可能になる。</li>
            <li><code>ROLLUP</code> と <code>GROUPING</code> を使えば、一発で小計・総合計を含む美しいレポートデータが生成できる。</li>
        </ul>
        <p>
            データ分析やバックエンド開発の実務において、これらの関数を使いこなせるかどうかで、コードのシンプルさとシステムのパフォーマンスが劇的に変わります。演習環境のダミーデータをいろいろと書き換えて、ぜひ様々なパターンの分析クエリを試してみてください。
        </p>

        <div class="footer">
            本コンテンツの作成時間：約10時間
        </div>
    </div>
</body>
</html>