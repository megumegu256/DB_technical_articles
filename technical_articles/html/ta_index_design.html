<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostgreSQLで学ぶインデックス設計の実践：B-treeから複合インデックスの罠まで</title>
    <style>
        :root {
            --primary-color: #3182ce;
            --bg-color: #f7fafc;
            --text-color: #2d3748;
            --code-bg: #edf2f7;
            --border-color: #e2e8f0;
            --alert-bg: #fffaf0;
            --alert-border: #ed8936;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: 850px;
            margin: 0 auto;
            background: #ffffff;
            padding: 3rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        h1 {
            font-size: 2rem;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
        }
        h2 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3rem;
        }
        h3 {
            font-size: 1.25rem;
            margin-top: 2rem;
            color: #4a5568;
            border-left: 5px solid var(--primary-color);
            padding-left: 0.8rem;
        }
        p {
            margin-bottom: 1.5rem;
        }
        ul, ol {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            border: 1px solid var(--border-color);
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .terminal-output {
            background-color: #2d3748;
            color: #e2e8f0;
            border: none;
        }
        .comment {
            color: #718096;
            font-style: italic;
        }
        code {
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            color: #d53f8c;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: var(--code-bg);
            font-weight: bold;
            color: #4a5568;
        }
        .note {
            background-color: #ebf8ff;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        .alert {
            background-color: var(--alert-bg);
            border: 1px solid var(--alert-border);
            border-left: 6px solid var(--alert-border);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .alert strong {
            color: #c05621;
            display: block;
            margin-bottom: 0.5rem;
        }
        .step-box {
            background-color: #fcfcfc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .step-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        .math {
            font-family: "Times New Roman", Times, serif;
            font-style: italic;
            font-size: 1.1em;
        }
        .footer {
            margin-top: 4rem;
            padding-top: 1rem;
            border-top: 1px dashed var(--border-color);
            text-align: right;
            color: #718096;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PostgreSQLで学ぶインデックス設計の実践：B-treeから複合インデックスの罠まで</h1>

        <h2>0. はじめに（この記事のゴール）</h2>
        <p>
            データベース工学の講義を通じて、私たちはSQLの基本からテーブル設計まで多くのことを学んできました。しかし、実際のシステム開発においてデータ量が数万、数十万と増えてくると、「正しいSQLを書いているのに、結果が返ってくるまでに何秒もかかる」という問題に直面します。
        </p>
        <p>
            このパフォーマンス問題を解決する鍵となるのが<strong>インデックス設計</strong>です。本記事では、講義の演習環境を使用し、実際に手を動かしながら以下のゴールを目指します。SQLの構文を少し忘れてしまった方でも大丈夫なように、適宜解説を挟みながら進めます。
        </p>
        <ul>
            <li>インデックス設計の目的と、それに伴うトレードオフを論理的に説明できる</li>
            <li>PostgreSQLの標準であるB-treeインデックスの仕組みと探索コストを理解する</li>
            <li><code>EXPLAIN / EXPLAIN ANALYZE</code> を使い、クエリの実行計画とインデックスの効果を測定できる</li>
            <li>単にインデックスを貼るだけでなく、「インデックスが効かないケース」を実験を通じて体感し、実務で通用する適切な設計ができるようになる</li>
        </ul>

        <h2>1. 実行環境とテーブル定義</h2>
        <p>本記事の SQL は、以下の環境で動作確認を行っています。読者の皆さんも、自身の環境で実際に手を動かしながら読み進めてください。</p>

        <h3>実行環境</h3>
        <ul>
            <li><strong>ホスト OS:</strong> Windows 11 (WSL2) または macOS</li>
            <li><strong>DBMS:</strong> PostgreSQL 17</li>
            <li><strong>Docker イメージ:</strong> postgres:17.6</li>
            <li><strong>ポート:</strong> 5432</li>
            <li><strong>接続方法:</strong> psql または 任意のデータベースクライアント</li>
        </ul>

        <div class="alert">
            <strong>⚠️ 環境構築に関する確認事項</strong>
            <ul>
                <li>Docker Desktop等のデーモンが起動していることを確認してください。</li>
                <li>すでにローカルのPCでポート <code>5432</code>（PostgreSQLのデフォルトポート）を使用している別のプロセスがある場合、コンテナの起動に失敗する可能性があります。その場合はポート番号を変更してください。</li>
                <li>
                    ターミナルから <code>psql -U (ユーザー名) -d (データベース名) -h localhost</code> 等のコマンドを実行し、確実にデータベースに接続できていることを確認してから実験に進んでください。<br>
                    <span style="font-size: 0.9em; color: #4a5568;">※接続に成功すると、以下のようにバージョン情報とプロンプト（<code>=&gt;</code> や <code>=#</code>）が表示され、SQLの入力待ち状態になります。</span>
<pre class="terminal-output" style="margin-top: 0.5rem; padding: 0.8rem; font-size: 0.85rem; border-radius: 4px;"><code>$ psql -U postgres -d postgres -h localhost
Password for user postgres: (パスワードを入力してEnter)
psql (17.6)
Type "help" for help.

postgres=# </code></pre>
                </li>
            </ul>
        </div>

        <h3>テーブル定義</h3>
        <p>本記事の実験では、以下のような <code>t_users</code>（ユーザー情報）テーブルを用います。</p>
<pre><code><span class="comment">-- ユーザー情報を格納するテーブルの作成</span>
CREATE TABLE t_users (
  id serial PRIMARY KEY,          <span class="comment">-- serial: 自動採番される整数型。PRIMARY KEY: 主キー</span>
  email text NOT NULL,            <span class="comment">-- text: 文字列型。NOT NULL: 空(NULL)を許容しない</span>
  age int NOT NULL,               <span class="comment">-- int: 整数型</span>
  status text NOT NULL,           <span class="comment">-- 状態を表す文字列（後ほど active/inactive を入れます）</span>
  created_at timestamp NOT NULL   <span class="comment">-- timestamp: 日時型（登録日時）</span>
);</code></pre>

        <p>第6章の実験では、このテーブルにダミーデータを<strong>20万件</strong>挿入して検証を行います。</p>

        <h2>2. インデックス（索引）とは何か</h2>
        <p>
            データベースにおける<strong>インデックス</strong>とは、テーブル内のデータを高速に検索するための「索引（さくいん）」データ構造のことです。分厚い技術書から特定のキーワードを探すとき、全ページを1枚ずつめくる（全件走査）のは非常に時間がかかります。そこで、巻末の「索引」を見て、そのキーワードが載っているページ番号を特定してから該当ページを開くはずです。データベースのインデックスも全く同じ役割を果たします。
        </p>
        <p>
            そして<strong>インデックス設計</strong>とは、「よく使われるクエリに対して、どのテーブルのどの列に、どのような種類のインデックスを作成するか」を決定する作業です。目的は、検索・結合・並べ替え・集計などの処理コストを劇的に下げることにあります。
        </p>

        <h3>2.1 インデックスとB-treeの仕組み</h3>
        <p>
            PostgreSQLにおいて、明示的に種類を指定せずにインデックスを作成した場合、標準で<strong>B-tree（Balanced Tree）</strong>というデータ構造が採用されます。
        </p>
        
        <div style="text-align: center; margin: 2rem 0;">
            <svg viewBox="0 0 650 300" xmlns="http://www.w3.org/2000/svg" style="background:#f7fafc; border:1px solid #e2e8f0; border-radius:8px; width:100%; max-width: 650px; height:auto; box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);">
                <style>
                    .node { fill: #ffffff; stroke: #3182ce; stroke-width: 2; rx: 6; ry: 6; }
                    .text { font-family: monospace; font-size: 16px; fill: #2d3748; text-anchor: middle; dominant-baseline: middle; font-weight: bold; }
                    .label { font-family: sans-serif; font-size: 12px; fill: #718096; }
                    .line { stroke: #cbd5e0; stroke-width: 2; }
                </style>
                <text x="20" y="50" class="label">Root Node</text>
                <text x="20" y="150" class="label">Branch Nodes</text>
                <text x="20" y="250" class="label">Leaf Nodes (データ)</text>
                <line x1="350" y1="50" x2="210" y2="150" class="line" />
                <line x1="350" y1="50" x2="490" y2="150" class="line" />
                <line x1="210" y1="150" x2="130" y2="250" class="line" />
                <line x1="210" y1="150" x2="290" y2="250" class="line" />
                <line x1="490" y1="150" x2="410" y2="250" class="line" />
                <line x1="490" y1="150" x2="570" y2="250" class="line" />
                <rect x="300" y="30" width="100" height="40" class="node" />
                <text x="350" y="50" class="text">50</text>
                
                <rect x="160" y="130" width="100" height="40" class="node" />
                <text x="210" y="150" class="text">20 | 40</text>
                
                <rect x="440" y="130" width="100" height="40" class="node" />
                <text x="490" y="150" class="text">60 | 80</text>
                
                <rect x="85" y="230" width="90" height="40" class="node" />
                <text x="130" y="250" class="text">10 | 15</text>
                
                <rect x="245" y="230" width="90" height="40" class="node" />
                <text x="290" y="250" class="text">25 | 35</text>
                
                <rect x="365" y="230" width="90" height="40" class="node" />
                <text x="410" y="250" class="text">55 | 58</text>
                
                <rect x="525" y="230" width="90" height="40" class="node" />
                <text x="570" y="250" class="text">65 | 90</text>
            </svg>
            <p style="font-size: 0.85rem; color: #718096; margin-top: 0.5rem;">図: B-treeの基本構造（木が浅く保たれ、データへのアクセス経路が整理されている）</p>
        </div>

        <p>
            B-treeは、ルート（根）ノードからブランチ（枝）ノードをたどり、目的のデータ（またはデータへのポインタ）が格納されているリーフ（葉）ノードへ到達する階層的な木構造になっています。
        </p>

        <h3>2.2 B-treeインデックスの強力な性質</h3>
        <p>
            B-treeには、リレーショナルデータベースで標準採用されるだけの強力な性質がいくつかあります。
        </p>
        <ul>
            <li><strong>常にバランスが保たれる（平衡性）：</strong> B-treeの「B」は Balanced（平衡）を意味します。データが追加・削除されても、木が自動的に再構築され、RootからすべてのLeafまでの深さ（距離）が常に一定に保たれます。これにより、どのデータを探す場合でも安定した検索速度（おおむね <span class="math">O(log n)</span> ）で結果を返すことができます。</li>
            <li><strong>範囲検索（Range Scan）に非常に強い：</strong> Leaf Nodeのデータは常にソート（昇順または降順）された状態で格納されており、かつ隣り合うノード同士がリンク（ポインタ）で繋がっています。そのため、「<code>id = 30</code> のデータ」といった等値検索だけでなく、「<code>id BETWEEN 20 AND 40</code>」のような範囲検索や、<code>ORDER BY</code> のような並べ替え処理を高速化するのにも劇的な効果を発揮します。</li>
        </ul>

        <h3>2.3 インデックスのコスト（トレードオフ）</h3>
        <p>
            「そんなに便利なら、すべての列にインデックスを作ればいいのではないか？」と思うかもしれません。しかし、インデックスには明確な<strong>トレードオフ（一方を追求すると、もう一方が犠牲になる関係）</strong>が存在します。
        </p>
        <p>
            前述の通り、インデックスは常にデータがソートされ、木のバランスが保たれた状態を維持しなければなりません。そのため、テーブルに対して <code>INSERT</code>（追加）, <code>UPDATE</code>（更新）, <code>DELETE</code>（削除）が行われるたびに、データベースは裏側でインデックスの木構造も律儀に並べ替えて更新しています。
        </p>
        <p>
            つまり、<strong>データの読み取り（SELECT）を劇的に高速化する代わりに、データの書き込み処理が遅くなり、さらにインデックス自体を保存するためのディスク容量も余分に消費する</strong>ことになります。これがインデックスを「本当に必要な列にだけ絞って作る」べき最大の理由です。
        </p>

        <h2>3. インデックスの種類と特徴（PostgreSQL）</h2>
        <p>PostgreSQLにはB-tree以外にも用途に応じたインデックスが用意されています。知識として整理しておきましょう。</p>
        <ul>
            <li><strong>B-tree:</strong> 等値検索（<code>=</code>）、範囲検索（<code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>）、<code>ORDER BY</code> に強い。実務のインデックスの9割以上はこれを使用します。</li>
            <li><strong>Hash:</strong> 等値検索のみに対応。B-treeよりサイズが小さくなる場合がありますが、用途が限られます。</li>
            <li><strong>GiST / GIN:</strong> 全文検索や、JSONB型、配列、位置情報（幾何データ）など、複雑なデータの検索に使用されます。</li>
            <li><strong>BRIN:</strong> 時系列のログデータなど、物理的な順序と論理的な順序が相関している巨大なテーブルに有効で、非常に省スペースです。</li>
        </ul>

        <h2>4. インデックス設計の基本原則</h2>
        <p>後述する実験では、以下の4つの基本原則が本当に正しいのかを実証していきます。ここで法則をしっかり頭に入れておいてください。</p>
        <ol>
            <li><strong>まずクエリを知る:</strong> アプリケーションが発行するSQLの <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code> に頻出する列を特定することから始めます。</li>
            <li><strong>選択度（Selectivity / カーディナリティ）を考える:</strong> その条件で「全体の何％までデータを絞り込めるか」が重要です。例えば「性別」のように2〜3種類しか値がない列にインデックスを貼っても効果は薄いです。</li>
            <li><strong>複合インデックスの順序:</strong> 複数の列を組み合わせた複合インデックスでは、第一条件で大きく絞り込める順序にするのが鉄則です。</li>
            <li><strong>過剰なインデックスを作らない:</strong> トレードオフを考慮し、実測で効果を確認してから追加します。</li>
        </ol>

        <h2>5. 実行計画の確認方法（EXPLAIN の見方）</h2>
        <p>
            実験に入る前に、PostgreSQLがどのようにクエリを実行しようとしているかを確認する <strong>EXPLAIN</strong>（エクスプレイン）コマンドについて解説します。<br>
            いつもの <code>SELECT</code> 文の先頭に <code>EXPLAIN ANALYZE</code> というキーワードをつけるだけで、ターミナル上に以下のような「実行計画（データベースの作戦内容）」が出力されます。
        </p>

        <p><strong>▼ターミナルに表示される実行計画の例</strong></p>
<pre class="terminal-output"><code># EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'test@example.com';

                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Scan using idx_t_users_email on t_users  (cost=0.42..8.44 rows=1 width=45) (actual time=0.031..0.032 rows=1 loops=1)
   Index Cond: (email = 'test@example.com'::text)
 Planning Time: 0.150 ms
 Execution Time: 0.051 ms
(4 rows)</code></pre>

        <p>この結果画面から、以下のポイントを読み取ります。ここを見比べることで、インデックスが本当に仕事をしているかがわかります。</p>
        <ul>
            <li><strong>Seq Scan / Index Scan (左端の文字):</strong> 
                <ul>
                    <li><code>Seq Scan</code> と書かれていたら、インデックスが使われず、テーブルを先頭から全件走査している証拠です（遅い）。</li>
                    <li><code>Index Scan</code> と書かれていたら、無事にインデックスを使って効率よく検索できています（速い）。</li>
                </ul>
            </li>
            <li><strong>cost=0.00..8.44 (カッコ内の数値):</strong> PostgreSQLが内部で計算した「推定の処理コスト」です。右側の数値が全体の推定コストを表します。</li>
            <li><strong>actual time=0.031..0.032:</strong> <code>ANALYZE</code> を付けた場合のみ表示される、実際の実行時間（ミリ秒単位）です。チューニングによってここが何ミリ秒減ったかを確認します。</li>
        </ul>

        <h2>6. 実験: インデックスの挙動と効果を検証する</h2>
        <p>ここからは、実際にコンテナ環境を用いて検証を進めます。順を追ってSQLを実行し、手元の環境でどのような結果が出たかを記録していきましょう。</p>

        <h3>6.1 検証用データセットの作成（準備）</h3>
        <p>
            インデックスの様々な挙動を確かめるため、20万件のダミーデータを作成します。ここでポイントとなるのは、<code>status</code> 列に意図的に「activeが90%、inactiveが10%」という偏りを持たせている点です。
        </p>
        <div class="alert">
            <strong>⚠️ データ生成時の注意</strong>
            <p>20万件のデータ生成には数秒〜十数秒かかる場合があります。クエリの実行が完了し、プロンプトが戻ってくるまで待機してください。</p>
        </div>
<pre><code><span class="comment">-- 既にテーブルがあれば削除（何度でも実験をやり直せるようにするため）</span>
DROP TABLE IF EXISTS t_users;

<span class="comment">-- テーブルの作成</span>
CREATE TABLE t_users (
    id serial PRIMARY KEY,
    email text NOT NULL,
    age int NOT NULL,
    status text NOT NULL,
    created_at timestamp NOT NULL
);

<span class="comment">-- 20万件のダミーデータを自動生成して挿入するクエリ</span>
INSERT INTO t_users (email, age, status, created_at)
SELECT
    <span class="comment">-- 例: 'user1@example.com' のように連番付きのアドレスを作る</span>
    'user' || i || '@example.com',
    <span class="comment">-- random()は0.0〜1.0の小数を返す。それに60を掛けて18を足し、18〜77歳の年齢を生成</span>
    (random() * 60)::int + 18,
    <span class="comment">-- 乱数が0.9未満なら 'active'、それ以外なら 'inactive' にする（90%と10%の偏り）</span>
    CASE WHEN random() < 0.9 THEN 'active' ELSE 'inactive' END,
    <span class="comment">-- 現在時刻(now())から、ランダムな日数（最大365日）を引いて過去の日付を作る</span>
    now() - (random() * interval '365 days')
<span class="comment">-- generate_series(1, 200000) で 1〜20万 までの連番 'i' を発生させる</span>
FROM generate_series(1, 200000) AS s(i);</code></pre>

        <h3>6.2 実験A: 基本的な Index Scan（等値検索）</h3>
        <p><strong>【基本原則1: まずクエリを知る】</strong>の裏付けとして、頻出する検索条件（メールアドレスの完全一致）に対してインデックスを作成し、効果を測定します。</p>

        <div class="step-box">
            <div class="step-title">【操作手順】</div>
            <ol>
                <li><strong>インデックス作成前の状態を確認する</strong>
                    <p>以下のクエリを実行し、<code>Seq Scan</code>になっていることと、<code>actual time</code>（実行時間）をメモしてください。</p>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'user150000@example.com';</code></pre>
                    <p class="comment">※筆者の環境での実測値： 約 (ここにミリ秒を記載) ms</p>
                </li>
                <li><strong>インデックスを作成する</strong>
                    <pre><code>CREATE INDEX idx_t_users_email ON t_users (email);</code></pre>
                </li>
                <li><strong>再度検索を実行し、比較する</strong>
                    <p>もう一度 1. と同じクエリを実行します。</p>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'user150000@example.com';</code></pre>
                    <p class="comment">※筆者の環境での実測値： 約 (ここにミリ秒を記載) ms</p>
                </li>
            </ol>
            <div class="note">
                <strong>【確認ポイント】</strong> 結果が <code>Index Scan using idx_t_users_email</code> に変化し、実行時間が劇的に短縮されているはずです。これがインデックスの基本となる威力です。
            </div>
        </div>

        <h3>6.3 実験B: インデックスが効かないケース①（LIKE検索）</h3>
        <p>B-treeは辞書順にデータが並んでいるため、検索の仕方によってはせっかく作ったインデックスが使えません。</p>
        
        <div class="step-box">
            <div class="step-title">【操作手順】</div>
            <ol>
                <li><strong>前方一致検索を実行する</strong>
                    <p>最初の文字がわかっている状態での検索です。</p>
                    <pre><code><span class="comment">-- 'user15' から始まるアドレスを検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email LIKE 'user15%';</code></pre>
                    <p>結果は <code>Index Scan</code>（または Bitmap Index Scan）になり、インデックスが有効に働いていることがわかります。</p>
                </li>
                <li><strong>後方一致検索を実行する</strong>
                    <p>末尾の文字しかわからない状態での検索です。</p>
                    <pre><code><span class="comment">-- '@example.com' で終わるアドレスを検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email LIKE '%@example.com';</code></pre>
                    <p>結果を確認すると、せっかくインデックスを作ったのに <code>Seq Scan</code> に戻ってしまっています。</p>
                </li>
            </ol>
            <div class="note">
                <strong>【考察】</strong> 後方一致検索ではインデックスが効きません。電話帳で「末尾が『郎』の人」を探すとき、結局全ページを見なければならないのと同じ理屈です。最初の文字が確定していないと、B-treeの木を適切にたどることはできないのです。
            </div>
        </div>

        <h3>6.4 実験C: インデックスが効かないケース②（選択度の問題）</h3>
        <p><strong>【基本原則2: 選択度を考える】</strong>の裏付け実験です。データに偏りを持たせた <code>status</code> 列にインデックスを貼り、検索する値によってPostgreSQLの挙動がどう変わるかを見ます。</p>

        <div class="step-box">
            <div class="step-title">【操作手順】</div>
            <ol>
                <li><strong>status列にインデックスを作成する</strong>
                    <pre><code>CREATE INDEX idx_t_users_status ON t_users (status);</code></pre>
                </li>
                <li><strong>少数派（全体の10%）を検索する</strong>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE status = 'inactive';</code></pre>
                    <p>こちらは高確率でインデックスを使った検索（Bitmap Index Scan等）が選ばれます。</p>
                </li>
                <li><strong>多数派（全体の90%）を検索する</strong>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE status = 'active';</code></pre>
                    <p>結果を確認すると、インデックスが存在するのに <code>Seq Scan</code> が選ばれているはずです。</p>
                </li>
            </ol>
            <div class="note">
                <strong>【考察】</strong> なぜ多数派を検索すると Seq Scan になるのでしょうか？それは、条件にヒットする件数が多すぎる場合、オプティマイザが「インデックスの木をたどってから実データをチマチマ引きに行くより、最初からテーブル全体をガサッと読み込んだ方がマシ（I/Oコストが低い）」と賢く判断するためです。選択度の低い列にインデックスを貼っても無意味であることがこれで実証されました。
            </div>
        </div>

        <h3>6.5 実験D: 複合インデックスの順序</h3>
        <p><strong>【基本原則3: 複合インデックスの順序】</strong>の裏付け実験です。複数列に対するインデックスの順序がどれほど重要かを確認します。</p>

        <div class="step-box">
            <div class="step-title">【操作手順】</div>
            <ol>
                <li><strong>複合インデックスを作成する</strong>
                    <pre><code><span class="comment">-- age を第1条件、created_at を第2条件として作成</span>
CREATE INDEX idx_t_users_age_created ON t_users (age, created_at);</code></pre>
                </li>
                <li><strong>第1列と第2列の両方を使って検索する</strong>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE age = 30 AND created_at > '2024-01-01';</code></pre>
                    <p>結果は <code>Index Scan</code>（または Bitmap Index Scan）になり、複合インデックスが完璧に機能します。</p>
                </li>
                <li><strong>第2列のみを使って検索する</strong>
                    <pre><code>EXPLAIN ANALYZE SELECT * FROM t_users WHERE created_at > '2024-01-01';</code></pre>
                    <p>結果は <code>Seq Scan</code> になってしまいます。</p>
                </li>
            </ol>
            <div class="note">
                <strong>【考察】</strong> 複合インデックスは左側の列（この場合は age）から順にソートされて木構造を作ります。そのため、第1列（大分類）の条件を指定してあげないと、第2列（小分類）単独では木をたどることができません。複合インデックスを作る際は「WHERE句で必ず指定され、かつ最も絞り込める列」を先頭に持ってくるのが鉄則です。
            </div>
        </div>

        <h2>7. 結果と考察まとめ</h2>
        <p>ここまでの実験を通じて、以下の重要な知見が実証されました。</p>
        <ul>
            <li>インデックスは万能魔法ではない。B-treeの構造上、前方一致や完全一致でなければ効果が薄い。</li>
            <li>条件に合致するデータが多すぎる（選択度が悪い）と、PostgreSQLのオプティマイザはあえてインデックスを無視する。</li>
            <li>複合インデックスは列の順序が命。<code>WHERE</code> 句で必ず指定され、かつ最も絞り込める列を先頭にする必要がある。</li>
        </ul>

        <h2>8. 演習課題</h2>
        <p>理解度を確認するため、以下の問題に挑戦してみてください。解答例を見る前に、手元の環境で <code>EXPLAIN</code> を使って自身の考えが正しいか検証してみましょう。</p>

        <h3>問題1：適切な複合インデックスの設計</h3>
        <p>次のクエリを最も効率よく高速化したい場合、どの列に、どのような順序で複合インデックスを作るべきでしょうか？</p>
<pre><code><span class="comment">-- LIMIT 50: 検索結果を最大50件だけ取得する</span>
SELECT * FROM t_users
WHERE status = 'inactive' AND age = 25
ORDER BY created_at DESC
LIMIT 50;</code></pre>

        <details style="margin-bottom: 2rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0;">
            <summary style="cursor: pointer; font-weight: bold;">解答例を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong> <code>CREATE INDEX idx_users_age_status_created ON t_users (age, status, created_at DESC);</code>
            </p>
            <p>
                <strong>解説：</strong> <code>status</code> よりも <code>age</code> の方が選択度が高い（値の種類が多く、1つの値でより少なく絞り込める）ため、<code>age</code> を先頭にするのがセオリーです。さらに <code>ORDER BY</code> のソート処理（コストの高い処理）をデータベースにスキップさせるために、ソート条件である <code>created_at DESC</code> もインデックスの末尾に含めると非常に高速になります。
            </p>
        </details>

        <h3>問題2：JOINを伴うクエリのインデックス</h3>
        <p>注文情報を管理する <code>orders</code> テーブルがあるとします。次のJOINクエリを高速化するには、どのテーブルのどの列にインデックスを作るべきでしょうか？</p>
<pre><code><span class="comment">-- ordersテーブルとusersテーブルを、idをキーにして結合(JOIN)する</span>
SELECT o.*
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.email = 'test@example.com';</code></pre>

        <details style="margin-bottom: 2rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0;">
            <summary style="cursor: pointer; font-weight: bold;">解答例を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong><br>
                <code>CREATE INDEX idx_users_email ON users (email);</code><br>
                <code>CREATE INDEX idx_orders_user_id ON orders (user_id);</code>
            </p>
            <p>
                <strong>解説：</strong> まず <code>WHERE</code> 句で絞り込みが行われる <code>users</code> テーブルの <code>email</code> 列にインデックスが必要です。次に、抽出された user の <code>id</code> を使って <code>orders</code> テーブルに結合しに行くため、結合の受け手となる <code>orders</code> テーブルの <code>user_id</code> 列（外部キー）にもインデックスが必須となります。
            </p>
        </details>

        <h2>9. まとめ</h2>
        <p>
            本記事では、インデックス（索引）自体の役割やB-treeの構造といった理論から入り、実際にPostgreSQLのオプティマイザがどのようにインデックスを選択（あるいは無視）するのかを実験を通じて確認しました。
        </p>
        <p>
            インデックス設計は「クエリ中心」で考えることが基本です。推測で設定するのではなく、必ず <code>EXPLAIN ANALYZE</code> を用いて「自分の意図通りに Index Scan が使われているか」を検証する癖をつけましょう。そして何より、読み取りを速くする代わりに書き込みコストと容量増という代償（トレードオフ）を払っていることを常に忘れないでください。
        </p>

        <div class="footer">
            本コンテンツの作成時間：約12時間
        </div>
    </div>
</body>
</html>