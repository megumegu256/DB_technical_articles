<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PostgreSQLで学ぶインデックス設計の実践：B-treeから複合インデックスの罠まで</title>
    <style>
        :root {
            --primary-color: #3182ce;
            --bg-color: #f7fafc;
            --text-color: #2d3748;
            --code-bg: #edf2f7;
            --border-color: #e2e8f0;
            --alert-bg: #fffaf0;
            --alert-border: #ed8936;
            --scenario-bg: #f0fff4;
            --scenario-border: #38a169;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: 850px;
            margin: 0 auto;
            background: #ffffff;
            padding: 3rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        h1 {
            font-size: 2rem;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
        }
        h2 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3rem;
        }
        h3 {
            font-size: 1.25rem;
            margin-top: 2rem;
            color: #4a5568;
            border-left: 5px solid var(--primary-color);
            padding-left: 0.8rem;
        }
        h4 {
            font-size: 1.1rem;
            margin-top: 1.5rem;
            color: #2d3748;
        }
        p {
            margin-bottom: 1.5rem;
        }
        ul, ol {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            border: 1px solid var(--border-color);
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .terminal-output {
            background-color: #2d3748;
            color: #e2e8f0;
            border: none;
        }
        .comment {
            color: #718096;
            font-style: italic;
        }
        code {
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            color: #d53f8c;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: var(--code-bg);
            font-weight: bold;
            color: #4a5568;
        }
        .note {
            background-color: #ebf8ff;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        .alert {
            background-color: var(--alert-bg);
            border: 1px solid var(--alert-border);
            border-left: 6px solid var(--alert-border);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .alert strong {
            color: #c05621;
            display: block;
            margin-bottom: 0.5rem;
        }
        .scenario {
            background-color: var(--scenario-bg);
            border: 1px solid var(--scenario-border);
            border-radius: 6px;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
        }
        .scenario-title {
            font-weight: bold;
            color: var(--scenario-border);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }
        .step-box {
            background-color: #fcfcfc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .step-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        .math {
            font-family: "Times New Roman", Times, serif;
            font-style: italic;
            font-size: 1.1em;
        }
        .terminal-img {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 1rem 0;
            display: block;
        }
        .footer {
            margin-top: 4rem;
            padding-top: 1rem;
            border-top: 1px dashed var(--border-color);
            text-align: right;
            color: #718096;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PostgreSQLで学ぶインデックス設計の実践：B-treeから複合インデックスの罠まで</h1>

        <h2>0. はじめに（この記事のゴール）</h2>
        <p>
            データベース工学の講義を通じて、私たちはSQLの基本からテーブル設計まで多くのことを学んできました。しかし、実際のシステム開発においてデータ量が数万、数十万と増えてくると、「正しいSQLを書いているのに、結果が返ってくるまでに何秒もかかる」という問題に直面します。
        </p>
        <p>
            このパフォーマンス問題を解決する鍵となるのが<strong>インデックス設計</strong>です。本記事では、講義の演習環境を使用し、実際に手を動かしながら以下のゴールを目指します。SQLの構文を少し忘れてしまった方でも大丈夫なように、適宜解説を挟みながら進めます。
        </p>
        <ul>
            <li>インデックス設計の目的と、それに伴うトレードオフを論理的に説明できる</li>
            <li>PostgreSQLの標準であるB-treeインデックスの仕組みと探索コストを理解する</li>
            <li><code>EXPLAIN / EXPLAIN ANALYZE</code> を使い、クエリの実行計画とインデックスの効果を測定できる</li>
            <li>単にインデックスを貼るだけでなく、「インデックスが効かないケース」を実験を通じて体感し、実務で通用する適切な設計ができるようになる</li>
        </ul>

        <h2>1. 実行環境とテーブル定義</h2>
        <p>本記事の SQL は、以下の環境で動作確認を行っています。読者の皆さんも、自身の環境で実際に手を動かしながら読み進めてください。</p>

        <h3>実行環境</h3>
        <ul>
            <li><strong>ホスト OS:</strong> Windows 11 (WSL2) または macOS</li>
            <li><strong>DBMS:</strong> PostgreSQL 17</li>
            <li><strong>Docker イメージ:</strong> postgres:17.6</li>
            <li><strong>ポート:</strong> 5432</li>
            <li><strong>接続方法:</strong> psql または 任意のデータベースクライアント</li>
        </ul>

        <div class="alert">
            <strong>⚠️ 環境構築に関する確認事項</strong>
            <ul>
                <li>Docker Desktop等のデーモンが起動していることを確認してください。</li>
                <li>すでにローカルのPCでポート <code>5432</code>（PostgreSQLのデフォルトポート）を使用している別のプロセスがある場合、コンテナの起動に失敗する可能性があります。その場合はポート番号を変更してください。</li>
                <li>
                    ターミナルから <code>psql -U (ユーザー名) -d (データベース名) -h localhost</code> 等のコマンドを実行し、確実にデータベースに接続できていることを確認してから実験に進んでください。<br>
                    <span style="font-size: 0.9em; color: #4a5568;">※接続に成功すると、以下のようにバージョン情報とプロンプト（<code>=&gt;</code> や <code>=#</code>）が表示され、SQLの入力待ち状態になります。</span>
<pre class="terminal-output" style="margin-top: 0.5rem; padding: 0.8rem; font-size: 0.85rem; border-radius: 4px;"><code>$ psql -U postgres -d postgres -h localhost
Password for user postgres: (パスワードを入力してEnter)
psql (17.6)
Type "help" for help.

postgres=# </code></pre>
                </li>
            </ul>
        </div>

        <h3>テーブル定義</h3>
        <p>本記事の実験では、以下のような <code>t_users</code>（ユーザー情報）テーブルを用います。</p>
<pre><code><span class="comment">-- ユーザー情報を格納するテーブルの作成</span>
CREATE TABLE t_users (
  id serial PRIMARY KEY,          <span class="comment">-- serial: 自動採番される整数型。PRIMARY KEY: 主キー</span>
  email text NOT NULL,            <span class="comment">-- text: 文字列型。NOT NULL: 空(NULL)を許容しない</span>
  age int NOT NULL,               <span class="comment">-- int: 整数型</span>
  status text NOT NULL,           <span class="comment">-- 状態を表す文字列（後ほど active/inactive を入れます）</span>
  created_at timestamp NOT NULL   <span class="comment">-- timestamp: 日時型（登録日時）</span>
);</code></pre>

        <p>第6章の実験では、このテーブルにダミーデータを<strong>20万件</strong>挿入して検証を行います。</p>

        <h2>2. インデックス（索引）とは何か</h2>
        <p>
            データベースにおける<strong>インデックス</strong>とは、テーブル内のデータを高速に検索するための「索引（さくいん）」データ構造のことです。分厚い技術書から特定のキーワードを探すとき、全ページを1枚ずつめくる（全件走査）のは非常に時間がかかります。そこで、巻末の「索引」を見て、そのキーワードが載っているページ番号を特定してから該当ページを開くはずです。データベースのインデックスも全く同じ役割を果たします。
        </p>
        <p>
            そして<strong>インデックス設計</strong>とは、「よく使われるクエリに対して、どのテーブルのどの列に、どのような種類のインデックスを作成するか」を決定する作業です。目的は、検索・結合・並べ替え・集計などの処理コストを劇的に下げることにあります。
        </p>

        <h3>2.1 インデックスとB-treeの仕組み</h3>
        <p>
            PostgreSQLにおいて、明示的に種類を指定せずにインデックスを作成した場合、標準で<strong>B-tree（Balanced Tree）</strong>というデータ構造が採用されます。
        </p>
        
        <div style="text-align: center; margin: 2rem 0;">
            <svg viewBox="0 0 650 300" xmlns="http://www.w3.org/2000/svg" style="background:#f7fafc; border:1px solid #e2e8f0; border-radius:8px; width:100%; max-width: 650px; height:auto; box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);">
                <style>
                    .node { fill: #ffffff; stroke: #3182ce; stroke-width: 2; rx: 6; ry: 6; }
                    .text { font-family: monospace; font-size: 16px; fill: #2d3748; text-anchor: middle; dominant-baseline: middle; font-weight: bold; }
                    .label { font-family: sans-serif; font-size: 12px; fill: #718096; }
                    .line { stroke: #cbd5e0; stroke-width: 2; }
                </style>
                <text x="20" y="50" class="label">Root Node</text>
                <text x="20" y="150" class="label">Branch Nodes</text>
                <text x="20" y="250" class="label">Leaf Nodes (データ)</text>
                <line x1="350" y1="50" x2="210" y2="150" class="line" />
                <line x1="350" y1="50" x2="490" y2="150" class="line" />
                <line x1="210" y1="150" x2="130" y2="250" class="line" />
                <line x1="210" y1="150" x2="290" y2="250" class="line" />
                <line x1="490" y1="150" x2="410" y2="250" class="line" />
                <line x1="490" y1="150" x2="570" y2="250" class="line" />
                <rect x="300" y="30" width="100" height="40" class="node" />
                <text x="350" y="50" class="text">50</text>
                <rect x="160" y="130" width="100" height="40" class="node" />
                <text x="210" y="150" class="text">20 | 40</text>
                <rect x="440" y="130" width="100" height="40" class="node" />
                <text x="490" y="150" class="text">60 | 80</text>
                <rect x="85" y="230" width="90" height="40" class="node" />
                <text x="130" y="250" class="text">10 | 15</text>
                <rect x="245" y="230" width="90" height="40" class="node" />
                <text x="290" y="250" class="text">25 | 35</text>
                <rect x="365" y="230" width="90" height="40" class="node" />
                <text x="410" y="250" class="text">55 | 58</text>
                <rect x="525" y="230" width="90" height="40" class="node" />
                <text x="570" y="250" class="text">65 | 90</text>
            </svg>
            <p style="font-size: 0.85rem; color: #718096; margin-top: 0.5rem;">図: B-treeの基本構造（木が浅く保たれ、データへのアクセス経路が整理されている）</p>
        </div>

        <p>
            B-treeは、ルート（根）ノードからブランチ（枝）ノードをたどり、目的のデータ（またはデータへのポインタ）が格納されているリーフ（葉）ノードへ到達する階層的な木構造になっています。
        </p>

        <h3>2.2 B-treeインデックスの強力な性質</h3>
        <p>
            B-treeには、リレーショナルデータベースで標準採用されるだけの強力な性質がいくつかあります。
        </p>
        <ul>
            <li><strong>常にバランスが保たれる（平衡性）：</strong> B-treeの「B」は Balanced（平衡）を意味します。データが追加・削除されても、木が自動的に再構築され、RootからすべてのLeafまでの深さ（距離）が常に一定に保たれます。これにより、どのデータを探す場合でも安定した検索速度（おおむね <span class="math">O(log n)</span> ）で結果を返すことができます。</li>
            <li><strong>範囲検索（Range Scan）に非常に強い：</strong> Leaf Nodeのデータは常にソート（昇順または降順）された状態で格納されており、かつ隣り合うノード同士がリンク（ポインタ）で繋がっています。そのため、「<code>id = 30</code> のデータ」といった等値検索だけでなく、「<code>id BETWEEN 20 AND 40</code>」のような範囲検索や、<code>ORDER BY</code> のような並べ替え処理を高速化するのにも劇的な効果を発揮します。</li>
        </ul>

        <h3>2.3 インデックスのコスト（トレードオフ）</h3>
        <p>
            「そんなに便利なら、すべての列にインデックスを作ればいいのではないか？」と思うかもしれません。しかし、インデックスには明確な<strong>トレードオフ（一方を追求すると、もう一方が犠牲になる関係）</strong>が存在します。
        </p>
        <p>
            前述の通り、インデックスは常にデータがソートされ、木のバランスが保たれた状態を維持しなければなりません。そのため、テーブルに対して <code>INSERT</code>（追加）, <code>UPDATE</code>（更新）, <code>DELETE</code>（削除）が行われるたびに、データベースは裏側でインデックスの木構造も律儀に並べ替えて更新しています。
        </p>
        <p>
            つまり、<strong>データの読み取り（SELECT）を劇的に高速化する代わりに、データの書き込み処理が遅くなり、さらにインデックス自体を保存するためのディスク容量も余分に消費する</strong>ことになります。これがインデックスを「本当に必要な列にだけ絞って作る」べき最大の理由です。
        </p>

        <h2>3. インデックスの種類と特徴（PostgreSQL）</h2>
        <p>PostgreSQLにはB-tree以外にも用途に応じたインデックスが用意されています。知識として整理しておきましょう。</p>
        <ul>
            <li><strong>B-tree:</strong> 等値検索（<code>=</code>）、範囲検索（<code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>）、<code>ORDER BY</code> に強い。実務のインデックスの9割以上はこれを使用します。</li>
            <li><strong>Hash:</strong> 等値検索のみに対応。B-treeよりサイズが小さくなる場合がありますが、用途が限られます。</li>
            <li><strong>GiST / GIN:</strong> 全文検索や、JSONB型、配列、位置情報（幾何データ）など、複雑なデータの検索に使用されます。</li>
            <li><strong>BRIN:</strong> 時系列のログデータなど、物理的な順序と論理的な順序が相関している巨大なテーブルに有効で、非常に省スペースです。</li>
        </ul>

        <h2>4. インデックス設計の基本原則</h2>
        <p>
            第2章で述べた通り、インデックスには「読み取りが速くなる代わりに、書き込みが遅くなる」という強いトレードオフがあります。そのため、適当な列に手当たり次第インデックスを貼る（オーバーインデックス）と、システム全体のパフォーマンスが逆に悪化してしまいます。<br>
            そこで、<strong>「どの列にインデックスを作るべきか」を見極めるためのシステム的なアプローチ</strong>が必要になります。実務において必ず意識すべき「4つの基本原則」を以下に示します。後述する実験パートでは、これらの法則が本当に正しいのかを実際に手を動かして検証していきます。
        </p>

        <ol>
            <li>
                <strong>まずクエリを知る（推測で作らない）</strong><br>
                インデックスは「アプリケーションが実際に発行するSQL」に合わせて設計するのが大前提です。テーブル定義書だけを眺めて「この列は検索されそうだ」と推測で作ってはいけません。実際のプログラムやログから、<code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code> 句に頻繁に登場する列を特定することから始めます。
            </li>
            <li>
                <strong>選択度（Selectivity / カーディナリティ）を考える</strong><br>
                「選択度」とは、ある検索条件を指定したときに「テーブル全体の何％までデータを絞り込めるか」を示す指標です。一般的に、<strong>テーブル全体の 5%〜10% 以下に絞り込める条件</strong>でなければ、インデックスは効果を発揮しません。<br>
                例えば「ユーザーID」や「メールアドレス」のように値がバラバラな列（カーディナリティが高い列）は効果絶大ですが、「性別」のように2〜3種類しか値がない列（カーディナリティが低い列）にインデックスを貼っても、テーブルの半分がヒットしてしまうため、多くの場合、PostgreSQLはインデックスを無視して全件走査（Seq Scan）を選んでしまいます。
            </li>
            <li>
                <strong>複合インデックスの順序</strong><br>
                複数の列を組み合わせた「複合インデックス（Composite Index）」を作る場合、<strong>（列A, 列B）と（列B, 列A）は全く異なる挙動</strong>をします。<br>
                複合インデックスは、指定された列の「左側から順に」ソートされて木構造を作るため、第一条件で大きく絞り込める順序にするのが鉄則です。電話帳が「苗字→名前」の順に並んでいるのに、「名前が『太郎』の人」を探すのが難しいのと同じ理屈です。
            </li>
            <li>
                <strong>過剰なインデックスを作らない</strong><br>
                インデックスは「作れば作るほど、書き込み性能とストレージ容量が犠牲になる」というトレードオフを強く意識してください。すべての <code>SELECT</code> をインデックス化するのは不可能です。新しく追加する際は、必ず実測（<code>EXPLAIN ANALYZE</code>等）で効果を確認してから本番環境に適用します。
            </li>
        </ol>

        <h2>5. 実行計画の確認方法（EXPLAIN の見方）</h2>
        <p>
            実験に入る前に、PostgreSQLがどのようにクエリを実行しようとしているかを確認する <strong>EXPLAIN</strong>（エクスプレイン）コマンドについて解説します。<br>
            いつもの <code>SELECT</code> 文の先頭に <code>EXPLAIN ANALYZE</code> というキーワードをつけるだけで、ターミナル上に以下のような「実行計画（データベースの作戦内容）」が出力されます。
        </p>

        <p><strong>▼ターミナルに表示される実行計画の例</strong></p>
<pre class="terminal-output"><code># EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'test@example.com';

                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Scan using idx_t_users_email on t_users  (cost=0.42..8.44 rows=1 width=45) (actual time=0.031..0.032 rows=1 loops=1)
   Index Cond: (email = 'test@example.com'::text)
 Planning Time: 0.150 ms
 Execution Time: 0.051 ms
(4 rows)</code></pre>

        <p>この結果画面から、以下のポイントを読み取ります。ここを見比べることで、インデックスが本当に仕事をしているかがわかります。</p>
        <ul>
            <li><strong>Seq Scan / Index Scan (左端の文字):</strong> 
                <ul>
                    <li><code>Seq Scan</code> と書かれていたら、インデックスが使われず、テーブルを先頭から全件走査している証拠です（遅い）。</li>
                    <li><code>Index Scan</code> または <code>Bitmap Index Scan</code> と書かれていたら、無事にインデックスを使って効率よく検索できています（速い）。</li>
                </ul>
            </li>
            <li><strong>cost=0.00..8.44 (カッコ内の数値):</strong> PostgreSQLが内部で計算した「推定の処理コスト」です。右側の数値が全体の推定コストを表します。</li>
            <li><strong>actual time=0.031..0.032:</strong> <code>ANALYZE</code> を付けた場合のみ表示される、実際の実行時間（ミリ秒単位）です。チューニングによってここが何ミリ秒減ったかを確認します。</li>
        </ul>

        <h2>6. 実験: インデックスの挙動と効果を検証する</h2>
        <p>ここからは、実際にコンテナ環境を用いて検証を進めます。順を追ってSQLを実行し、手元の環境でどのような結果が出たかを記録していきましょう。</p>

        <h3>6.1 検証用データセットの作成（準備）</h3>
        <p>
            インデックスの様々な挙動を確かめるため、20万件のダミーデータを作成します。ここでポイントとなるのは、<code>status</code> 列に意図的に「activeが90%、inactiveが10%」という偏りを持たせている点です。
        </p>
        <div class="alert">
            <strong>⚠️ データ生成時の注意</strong>
            <p>20万件のデータ生成には数秒〜十数秒かかる場合があります。クエリの実行が完了し、プロンプトが戻ってくるまで待機してください。</p>
        </div>
<pre><code><span class="comment">-- 既にテーブルがあれば削除（何度でも実験をやり直せるようにするため）</span>
DROP TABLE IF EXISTS t_users;

<span class="comment">-- テーブルの作成</span>
CREATE TABLE t_users (
    id serial PRIMARY KEY,
    email text NOT NULL,
    age int NOT NULL,
    status text NOT NULL,
    created_at timestamp NOT NULL
);

<span class="comment">-- 20万件のダミーデータを自動生成して挿入するクエリ</span>
INSERT INTO t_users (email, age, status, created_at)
SELECT
    <span class="comment">-- 例: 'user1@example.com' のように連番付きのアドレスを作る</span>
    'user' || i || '@example.com',
    <span class="comment">-- random()は0.0〜1.0の小数を返す。それに60を掛けて18を足し、18〜77歳の年齢を生成</span>
    (random() * 60)::int + 18,
    <span class="comment">-- 乱数が0.9未満なら 'active'、それ以外なら 'inactive' にする（90%と10%の偏り）</span>
    CASE WHEN random() < 0.9 THEN 'active' ELSE 'inactive' END,
    <span class="comment">-- 現在時刻(now())から、ランダムな日数（最大365日）を引いて過去の日付を作る</span>
    now() - (random() * interval '365 days')
<span class="comment">-- generate_series(1, 200000) で 1〜20万 までの連番 'i' を発生させる</span>
FROM generate_series(1, 200000) AS s(i);</code></pre>

        <h3>6.2 実験A: 基本的な Index Scan（等値検索）</h3>
        
        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> Webサービスのログイン画面で、ユーザーが入力したメールアドレスをもとに、20万件の会員データベースから該当する1件のユーザー情報を探し出す。<br>
                <strong>検証の狙い：</strong> インデックスがない場合（Seq Scan）と、作成した場合（Index Scan）で、検索速度にどれほどの劇的な差が生まれるかという「基本原則1」の裏付けとなる効果を実証します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>インデックス作成前後の状態を比較する</strong>
                    <p>以下のクエリを実行し、インデックス作成前後で <code>Seq Scan</code> から <code>Index Scan</code> にどう変化したかを確認します。</p>
                    <pre><code><span class="comment">-- ① インデックス作成前の検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'user150000@example.com';

<span class="comment">-- ② インデックスの作成</span>
CREATE INDEX idx_t_users_email ON t_users (email);

<span class="comment">-- ③ インデックス作成後の検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email = 'user150000@example.com';</code></pre>
                </li>
            </ol>
            <p><strong>▼実際のターミナル出力結果</strong></p>
            <img src="../png/index_a.png" alt="実験Aのターミナル出力" class="terminal-img">
            <div class="note">
                <strong>【結論】</strong> 画像の通り、結果が <code>Seq Scan</code> から <code>Index Scan</code> に変化し、実行時間は 15.928 ms から 0.090 ms へと<strong>約177倍も高速化</strong>されました。また、Seq Scan時は <code>Rows Removed by Filter: 199999</code>（関係ない19万件のデータを無駄に読み込んで捨てた）と出力されており、全件走査の非効率さが明確に現れています。
            </div>
        </div>

        <h3>6.3 実験B: インデックスが効かないケース①（LIKE検索）と環境の罠</h3>
        
        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 管理画面で特定の文字列を含むメールアドレスを持つユーザーを検索する際、「user15から始まるアドレス（前方一致）」と、「@example.comで終わるアドレス（後方一致）」をそれぞれ検索する。<br>
                <strong>検証の狙い：</strong> B-treeインデックスは辞書順にデータが並んでいるため、「前方一致」ならインデックスが効き、「後方一致」では効かないことを実証します。さらに、本講義のコンテナ環境（日本語ロケール）特有の「罠」とその解決策も提示します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>通常のインデックスで前方一致検索を実行する（罠の発見）</strong>
                    <p>実験Aで作成したインデックスがある状態で、前方一致検索を実行してみます。</p>
                    <pre><code><span class="comment">-- 'user15' から始まるアドレスを検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email LIKE 'user15%';</code></pre>
                    <p><strong>▼実際のターミナル出力結果（罠の発生）</strong></p>
                    <img src="../png/index_b_0.png" alt="実験Bの前方一致検索での罠" class="terminal-img">
                    <p><strong>【罠の解説】</strong> B-treeは前方一致に強いはずなのに、なぜか <code>Seq Scan</code> （19.250 ms）になってしまいました。実は、PostgreSQLのデータベース言語設定（ロケール）が日本語環境などの場合、文字の並び順ルールが複雑になるため、通常の <code>CREATE INDEX</code> では <code>LIKE</code> 検索にインデックスが使われません。</p>
                </li>
                <li><strong>LIKE検索に対応したインデックスを作り直す</strong>
                    <p>この罠を回避するため、<code>text_pattern_ops</code> という特殊なオプションを指定してインデックスを再作成し、再度検証します。</p>
                    <pre><code><span class="comment">-- 既存のインデックスを削除</span>
DROP INDEX idx_t_users_email;
<span class="comment">-- LIKE検索用の演算子クラスを指定して作成</span>
CREATE INDEX idx_t_users_email_pattern ON t_users (email text_pattern_ops);

<span class="comment">-- ① 再度、前方一致検索を実行する</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email LIKE 'user15%';

<span class="comment">-- ② 後方一致検索も実行してみる</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE email LIKE '%@example.com';</code></pre>
                </li>
            </ol>
            <p><strong>▼実際のターミナル出力結果（解決策と後方一致の限界）</strong></p>
            <img src="../png/index_b_1.png" alt="実験Bの解決策と後方一致の限界" class="terminal-img">
            <div class="note">
                <strong>【結論】</strong> 修正後の前方一致検索は、見事に <code>Bitmap Index Scan</code> に切り替わりました。実行計画を見ると、条件が <code>(email ~&gt;=~ 'user15') AND (email ~&lt;~ 'user16')</code> のように「user15以上、user16未満」という範囲検索にPostgreSQL内部で自動翻訳され高速化されています。<br>
                一方、後方一致検索（画像下の実行結果）は <code>Seq Scan</code>（29.374 ms）のままでした。電話帳で「末尾が『郎』の人」を探すとき全ページを見なければならないのと同じで、最初の文字が確定していないとB-treeの木はたどれないことが証明されました。
            </div>
        </div>

        <h3>6.4 実験C: インデックスが効かないケース②（選択度の問題）</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> 分析ダッシュボードにて、「退会済みのユーザー（全体の約10%）」と、「現在利用中のユーザー（全体の約90%）」の情報をそれぞれ一覧で取得する。<br>
                <strong>検証の狙い：</strong> 「基本原則2: 選択度を考える」の裏付けです。カーディナリティの低い列（statusなど値の種類が少ない列）にインデックスを貼っても、条件によってPostgreSQLの賢いオプティマイザがあえてインデックスを無視することを確認します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>status列にインデックスを作成し、それぞれ検索する</strong>
                    <pre><code>CREATE INDEX idx_t_users_status ON t_users (status);

<span class="comment">-- 少数派（全体の約10%）を検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE status = 'inactive';

<span class="comment">-- 多数派（全体の約90%）を検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE status = 'active';</code></pre>
                </li>
            </ol>
            <p><strong>▼実際のターミナル出力結果</strong></p>
            <img src="../png/index_c.png" alt="実験Cのターミナル出力" class="terminal-img">
            <div class="note">
                <strong>【結論】</strong> 画像の通り、少数派の検索では <code>Bitmap Index Scan</code>（5.908 ms）が使われましたが、多数派の検索ではインデックスが存在するのに <code>Seq Scan</code> に逆戻りしました。<br>
                条件にヒットする件数が多すぎる場合、オプティマイザは「インデックスをたどってから実データをバラバラに拾いに行くより、最初からテーブル全体を先頭から一気に舐めた方が、ディスクI/Oのコストが安く済む」と計算して判断します。選択度の低い列に単独でインデックスを貼っても無意味であることが実証されました。
            </div>
        </div>

        <h3>6.5 実験D: 複合インデックスの順序</h3>

        <div class="scenario">
            <div class="scenario-title">📌 想定シーンと検証の狙い</div>
            <p>
                <strong>想定シーン：</strong> カスタマーサポートの画面で、「年齢が30歳 かつ 2024年以降に登録したユーザー」を探し出す。そのために <code>age</code> と <code>created_at</code> の複合インデックスを作成する。<br>
                <strong>検証の狙い：</strong> 「基本原則3: 複合インデックスの順序」の裏付けです。複合インデックスは左側の列から順にソートされるため、第1列（ここではage）の条件を指定しないと、せっかくの複合インデックスが使えないという重要な特性を検証します。
            </p>
        </div>

        <div class="step-box">
            <div class="step-title">【操作手順と検証】</div>
            <ol>
                <li><strong>複合インデックスを作成し、条件を変えて検索する</strong>
                    <pre><code><span class="comment">-- age を第1条件、created_at を第2条件として作成</span>
CREATE INDEX idx_t_users_age_created ON t_users (age, created_at);

<span class="comment">-- ① 第1列と第2列の両方を使って検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE age = 30 AND created_at > '2024-01-01';

<span class="comment">-- ② 第2列のみを使って検索</span>
EXPLAIN ANALYZE SELECT * FROM t_users WHERE created_at > '2024-01-01';</code></pre>
                </li>
            </ol>
            <p><strong>▼実際のターミナル出力結果</strong></p>
            <img src="../png/index_d.png" alt="実験Dのターミナル出力" class="terminal-img">
            <div class="note">
                <strong>【結論】</strong> 画像上部の通り、両方の列を指定した検索は <code>Bitmap Index Scan</code>（2.924 ms）となり完璧に機能しました。しかし画像下部の通り、第2列単独での検索は <code>Seq Scan</code>（26.710 ms）となってしまいました。<br>
                複合インデックスを作る際は「WHERE句で必ず指定され、かつ最も絞り込める列」を先頭に持ってくるのが絶対の鉄則です。
            </div>
        </div>

        <h2>7. 結果と考察まとめ</h2>
        <p>ここまでの実験を通じて、インデックス設計における4つの基本原則が実証されました。</p>
        <ul>
            <li><strong>インデックスの基本となる威力（実験A）：</strong> 適切な列にインデックスを貼ることで、全件走査（Seq Scan）から解放され、実行時間が劇的に（今回の実験では170倍以上）高速化される。</li>
            <li><strong>検索手法とロケールの罠（実験B）：</strong> B-treeは前方一致に強いが、後方一致では効果がない。また、日本語ロケール環境では <code>text_pattern_ops</code> を指定しないと <code>LIKE</code> 検索にインデックスが使われないという実務的な罠がある。</li>
            <li><strong>選択度の重要性（実験C）：</strong> 条件に合致するデータが多すぎる（選択度が悪い）と、PostgreSQLのオプティマイザはディスクI/Oのコストを計算し、あえてインデックスを無視して Seq Scan を選択する。</li>
            <li><strong>複合インデックスの順序（実験D）：</strong> 複合インデックスは指定した列の左側から順に木構造を作るため、<code>WHERE</code> 句で第一条件として指定される列を先頭にしなければ効果を発揮しない。</li>
        </ul>

        <h2>8. 演習課題</h2>
        <p>ここまでの内容の定着度を確認するため、5つの実践的な問題に挑戦してみてください。難易度は徐々に上がっていきます。<br>
        実務の開発現場で「なぜそのクエリが遅いのか？」を突き止めるつもりで、解答例を開く前にぜひ自身の考えをまとめてみてください。</p>

        <h3>問題1：適切な複合インデックスの設計（難易度：⭐）</h3>
        <p>
            <strong>【場面・背景】</strong><br>
            社内の会員管理システムで、「退会済みの25歳のユーザー」を抽出し、登録日の新しい順に50件だけ一覧画面に表示する機能を追加することになりました。本記事の <code>t_users</code> テーブルに対して、以下のクエリが発行されます。
        </p>
<pre><code>SELECT * FROM t_users
WHERE status = 'inactive' AND age = 25
ORDER BY created_at DESC
LIMIT 50;</code></pre>
        <p>このクエリを最も効率よく高速化したい場合、どの列に、どのような順序で複合インデックスを作るべきでしょうか？</p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong> <code>CREATE INDEX idx_users_age_status_created ON t_users (age, status, created_at DESC);</code><br>
                <span style="font-size: 0.9em; color: #718096;">※ (status, age, created_at DESC) でも可</span>
            </p>
            <p>
                <strong>解説：</strong> 複合インデックスを設計する際の基本テクニックです。まず、<code>WHERE</code>句の等値検索の対象となっている <code>age</code> と <code>status</code> を先頭に置きます（この2つはどちらが先でも大きな差はありませんが、一般的に値の種類が多い＝選択度が高い <code>age</code> を先にするのがセオリーです）。<br>
                さらに重要なのが、<code>ORDER BY</code> のソート条件である <code>created_at DESC</code> をインデックスの末尾に含める点です。これにより、データベースは「ソート済みのインデックス」から条件に合うものを上から50件拾うだけで処理が完了するため、非常に重いソート処理を丸ごとスキップでき、クエリが劇的に高速化します。
            </p>
        </details>

        <h3>問題2：JOINを伴うクエリのインデックス（難易度：⭐⭐）</h3>
        <p>
            <strong>【場面・背景】</strong><br>
            ECサイトのマイページ機能です。ログイン中のユーザーのメールアドレスをキーにして、そのユーザーの過去の注文履歴（<code>orders</code> テーブル）をすべて取得する画面を作っています。
        </p>
<pre><code><span class="comment">-- ordersテーブルとusersテーブルを、idをキーにして結合(JOIN)する</span>
SELECT o.*
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.email = 'test@example.com';</code></pre>
        <p>このJOINクエリを高速化するには、どのテーブルのどの列にインデックスが必要でしょうか？（テーブルは2つあります）</p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong><br>
                1. <code>CREATE INDEX idx_users_email ON users (email);</code><br>
                2. <code>CREATE INDEX idx_orders_user_id ON orders (user_id);</code>
            </p>
            <p>
                <strong>解説：</strong> JOINクエリでは「駆動表（先に読み込まれるテーブル）」と「内部表（後から結合されるテーブル）」の2つの側面からインデックスを考えます。<br>
                まず、<code>WHERE</code> 句で絞り込みが行われる <code>users</code> テーブルの <code>email</code> 列にインデックスが必要です。次に、抽出された user の <code>id</code> を使って <code>orders</code> テーブルに結合しに行くため、結合の受け手（内部表）となる <code>orders</code> テーブルの <code>user_id</code> 列（外部キー）にもインデックスが必須となります。「外部キー制約の列には必ずインデックスを貼る」と覚えておきましょう。
            </p>
        </details>

        <h3>問題3：関数を用いた検索の罠（難易度：⭐⭐⭐）</h3>
        <p>
            <strong>【場面・背景】</strong><br>
            グローバル展開しているWebサービスのログイン処理です。ユーザーがメールアドレスを入力する際、大文字・小文字を適当に入力してもログインできるように、SQL側で <code>lower()</code> 関数を使ってすべて小文字に変換してから比較する仕様になっています。<br>
            ※<code>t_users</code> テーブルの <code>email</code> 列には、すでに単一のインデックスが作成済みです。
        </p>
<pre><code>SELECT * FROM t_users 
WHERE lower(email) = 'alice@example.com';</code></pre>
        <p>実は、このクエリを実行するとインデックスが一切使われず、<strong>Seq Scan</strong> になってしまいます。なぜインデックスが効かないのでしょうか？また、これを解決するにはどのようなコマンドを実行すべきでしょうか？</p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong><br>
                列に対して関数や演算（例: <code>email || '@'</code> や <code>age + 1</code> など）を適用すると、元のインデックスの木構造（ソート順）と一致しなくなるため、インデックスは無効化されてしまいます。<br>
                解決策として、関数の実行結果をあらかじめインデックス化する<strong>「式インデックス（関数インデックス）」</strong>を作成します。<br>
                <code>CREATE INDEX idx_users_lower_email ON t_users (lower(email));</code>
            </p>
            <p>
                <strong>解説：</strong> 「インデックスを貼った列は裸のまま（関数の引数に入れたり四則演算したりしない）でWHERE句に書く」というのはSQLチューニングの絶対の鉄則です。どうしても関数を通した結果で検索したい場合は、このように式インデックスを活用します。
            </p>
        </details>

        <h3>問題4：範囲検索とソートの罠（難易度：⭐⭐⭐⭐）</h3>
        <p>
            <strong>【場面・背景】</strong><br>
            ニュースメディアのシステムです。トップページに「特定のカテゴリ（<code>category_id = 5</code>）に属する記事のうち、<strong>2024年以降に公開されたもの</strong>を、<strong>閲覧数（views）が多い順</strong>に10件表示する」という機能を作ります。
        </p>
<pre><code>SELECT * FROM articles 
WHERE category_id = 5 
  AND published_at >= '2024-01-01' 
ORDER BY views DESC 
LIMIT 10;</code></pre>
        <p>このクエリを高速化するために複合インデックスを作ります。<code>category_id</code> を先頭にするのは基本ですが、その後ろの列はどういう順番で指定するのが最もパフォーマンスが良いでしょうか？</p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong> <code>CREATE INDEX idx_articles_cat_views ON articles (category_id, views DESC);</code>
            </p>
            <p>
                <strong>解説：</strong> 非常にひっかけになりやすい、高度な問題です。「WHERE句の条件を前に持ってくる」というセオリーに従って <code>(category_id, published_at, views DESC)</code> と作りたくなりますよね。しかし、B-treeインデックスは<strong>範囲検索（<code>&gt;=</code> など）の条件が現れた時点で、それより右側に定義された列によるソート（ORDER BY）をインデックスだけで処理できなくなります</strong>。<br>
                そのため、範囲検索の列をあえて後回しにし、「等値検索（<code>=</code>）の列 → <code>ORDER BY</code> の列」の順序で作成し、ソート処理をスキップさせるのがこの場合の正解（最もI/Oコストが下がる設計）となります。
            </p>
        </details>

        <h3>問題5：巨大テーブルの最適化戦略（難易度：⭐⭐⭐⭐⭐）</h3>
        <p>
            <strong>【場面・背景】</strong><br>
            巨大なタスク管理（To-Do）アプリのデータベースです。<code>tasks</code> テーブルには<strong>1000万件</strong>のタスクが保存されていますが、そのうち99%はすでに「完了（<code>status = 'done'</code>）」しており、検索されることは滅多にありません。<br>
            アプリケーションで最も頻繁に実行され、かつシステムに負荷をかけているのは、「特定のユーザーの、まだ『未完了（<code>status = 'todo'</code>）』のタスク一覧を取得する」クエリです。
        </p>
<pre><code>SELECT * FROM tasks 
WHERE assignee_id = 123 
  AND status = 'todo';</code></pre>
        <p><code>(assignee_id, status)</code> の複合インデックスを作れば高速化できるのは明らかです。しかし、1000万件すべてをインデックス化するのは、ディスク容量の無駄使いであり、タスク完了時の更新コストも跳ね上がってしまいます。<br>
        このケースにおいて、PostgreSQLの機能を使って<strong>最も効率的で無駄のないインデックスを作成するコマンド</strong>を考えてください。</p>

        <details style="margin-bottom: 2.5rem; background: #f7fafc; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 6px;">
            <summary style="cursor: pointer; font-weight: bold; color: var(--primary-color);">解答例と解説を見る</summary>
            <p style="margin-top: 1rem;">
                <strong>解答：</strong> <code>CREATE INDEX idx_tasks_todo ON tasks (assignee_id) WHERE status = 'todo';</code>
            </p>
            <p>
                <strong>解説：</strong> PostgreSQLの超強力な機能である<strong>「部分インデックス（Partial Index）」</strong>を活用します。インデックスを作成する際、末尾に <code>WHERE</code> 句をつけることで、<strong>条件を満たす行（今回は全体の1%しかない未完了タスク）だけをインデックスの木構造に登録する</strong>ことができます。<br>
                これにより、インデックスのサイズが劇的に小さくなり、メモリ（RAM）上にも乗りやすくなるため、検索が超高速になります。さらに、99%を占める「完了タスク」が更新・削除されてもこのインデックスはメンテナンスされないため、更新パフォーマンスの悪化も防ぐことができる、まさに一石二鳥のテクニックです。
            </p>
        </details>

        <h2>9. まとめ</h2>
        <p>
            本記事では、インデックス（索引）自体の役割やB-treeの構造といった理論から入り、実際にPostgreSQLのオプティマイザがどのようにインデックスを選択（あるいは無視）するのかを、講義のDocker環境を用いた実験を通じて確認しました。
        </p>
        <p>
            インデックス設計は「クエリ中心」で考えることが基本です。推測だけで設計するのではなく、必ず <code>EXPLAIN ANALYZE</code> を用いて「自分の意図通りに Index Scan が使われているか」を検証する癖をつけましょう。そして何より、読み取りを速くする代わりに書き込みコストとストレージ容量増という代償（トレードオフ）を払っていることを常に忘れないでください。
        </p>
        <p>
            実務のバックエンド開発やデータベース運用において、この「実行計画を読み解き、適切なインデックスを設計する力」は必ず皆さんの強力な武器になります。この記事が、パフォーマンスチューニングの第一歩となれば幸いです。
        </p>

        <div class="footer">
            本コンテンツの作成時間：約20時間
        </div>
    </div>
</body>
</html>